{"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"Azure DevOps Stakeholder 權限看不到 Repo","text":"問題描述我們使用 CI/CD 平台是 Azure DevOps，我們預計想做 Side project，想把技術支援連結放在 Wiki，朋友說他有將我們每一個人權限設置為 Admin，另外也有用 git 控管 Wiki，而我遇到的問題是無法在平台的 side menu 找到 Repo 圖示，於是我跳出來組織的畫面，從 Project 的 Repo 圖示點，但卻看到 403 無權限存取。 解決辦法後來我才發現原來即便專案的權限開到最大，成員仍無法存取某些功能。 建立專案後，邀請其他人加入某一專案內，此人若沒有在這個組織內，系統會將其權限設定為 Stakeholder 的角色。 Stakeholder 的角色是沒有版本控制的功能可以使用，換句話說開發人員角色必須是 Basic 或 Visual Studio Subscriber。 第二點合理的原因是因為利害關係人不應該觸碰版本控制的東西，他的職責所在在於「驗收產品」。 操作設定首先，從專案頁面跳回去組織頁面，找到 side menu 的 Organization settings 從 Organization settings 找到 Users，可以發現邀請的組員都會在裡面 接著對應該是開發人員的組員 Access Level 調整成 Basic 或 Visual Studio Subscriber。 最後調整完，那我們就可以看到 Repo 的功能了 :D 參考資源[Fixed] Cannot see Repos in Azure DevOps with Stakeholder Access 【把玩Azure DevOps】Day3 Organization與Projects","link":"/2022/03/31/Azure-DevOps-Stakeholder-%E6%AC%8A%E9%99%90%E7%9C%8B%E4%B8%8D%E5%88%B0-Repo/"},{"title":"[Java] BigDecimal 精度計算","text":"問題實務上，我們在程式中處理與金錢相關的議題不會使用浮點數，因為那會造成 Truncate Error，算出來的金額會有浮點數誤差，通常我們會使用 BigDecimal 來計算，提高計算的精度。 而我曾經要計算某金額除以匯率，計算結果四捨五入小數點取到第二位，於是我就寫了以下範例，使用 BigDecimal 除法，分別填入除數與 MathContext ， MathContext 的建構子的第一參數 setPrecision ，我以為設定的是小數點的精度，但事與願達，結果是2.4E2即 240 以科學記號表示。 1234BigDecimal dividend = new BigDecimal(&quot;999999.9999&quot;);BigDecimal divisor = new BigDecimal(&quot;4096.00&quot;);BigDecimal result = dividend.divide(divisor, new MathContext(2, RoundingMode.HALF_UP));System.out.println(result); Scale, Precision傻傻分不清楚由於上述計算結果並不是我想要，我在網路上找到 BigDecimal 對 Scale , Precision 的介紹，我才赫然發現一開始我就搞錯用法了，原來 BigDecimal 也像 IEEE-754 採用類似的表示方式。 BigDecimal表示法 Java BigDecimal 是由兩個數值所構成的，分別是隨機的精度整數、跟 32 位元整數範圍，通常BigDecimal以表示，其中n為小數位數。 Precision 精度定義是未經 BigDecimal 正規表示的數值之位數，即該數值整數加上小數的數位，例如： 123.45 ，此精度會回傳 5 。 Scale 範圍定義是經 BigDecimal 正規表示後的小數位數，如果 Scale 是零、正整數，則會將該數的數個位數挪動到小數點符號的右邊，如若 Scale 是負整數，則該值會乘上 10 的幂次，例如： 12345 ， scale = 2，則回傳 123.45 ， 12345 ， scale = -1 ，則回傳 123450 。 解決方法承上述例子，因為精度是設定 2 ，舊版的寫法會造成四捨五入到十位數，十數位以下通通進位，並以科學記號表示。解決方法是改用 BigDecimal 另一個重載 divide 的方法，就可以在第二參數設定小數範圍為 2 ，最後結果為244.14。 12345public class BigDecimal extends Number implements Comparable&lt;BigDecimal&gt; { public BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode) { return divide(divisor, scale, roundingMode.oldMode); }} 1234BigDecimal dividend = new BigDecimal(&quot;999999.9999&quot;);BigDecimal divisor = new BigDecimal(&quot;4096.00&quot;);BigDecimal result = dividend.divide(divisor, 2, RoundingMode.HALF_UP);System.out.println(result);","link":"/2022/03/08/BigDecimal-%E7%B2%BE%E5%BA%A6%E8%A8%88%E7%AE%97/"},{"title":"[Heroku][Flask] Couldn&#39;t find that process type (web).","text":"問題描述朋友想製造一個 LINE 機器人，自學學習撰寫 Python Flask Web Framework ，並部署到 Heroku 上，預期傳訊息時機器人會自動回覆相同的訊息內容，但卻沒有顯示在對話視窗內，於是拜託我幫他看。 首先要看的就是 Heroku console log ，下 heroku logs --tail 從裡面一定可以找出一些蛛絲馬跡，果不其然看到一些訊息，從日誌檔可得知程式是包版成功的，但很顯然程式發生錯誤， Web server 根本就沒有啟動，官方網站給出的解決方法是下 heroku ps:scale web=1 這組指令，以手動方式將 Web server 程序部署到他們的引擎 dyno 上。 Heroku 上日誌檔122022-03-12T05:20:20.000000+00:00 app[api]: Build succeeded2022-03-12T05:20:30.962092+00:00 heroku[router]: at=error code=H14 desc=&quot;No web processes running&quot; method=GET path=&quot;/favicon.ico&quot; host=groupbuyingchatbot.herokuapp.com request_id=808970d4-836d-40e6-9f8a-1e3b3a999199 fwd=&quot;42.77.131.204&quot; dyno= connect= service= status=503 bytes= protocol=https Heroku H14 錯誤代碼解釋1234567H14 - No web dynos runningThis is most likely the result of scaling your web dynos down to 0 dynos. To fix it, scale your web dynos to 1 or more dynos:heroku ps:scale web=1Use the heroku ps command to determine the state of your web dynos.2010-10-06T21:51:37-07:00 heroku[router]: at=error code=H14 desc=&quot;No web processes running&quot; method=GET path=&quot;/&quot; host=myapp.herokuapp.com fwd=17.17.17.17 dyno= connect= service= status=503 bytes= 你以這樣就解決問題了嗎？並沒有！我下了這道指令回覆訊息仍是找不是 Web Server 的程序，後續我確認了 Python 有沒有語法上的錯誤、部署腳本、套件 requirements.txt，也嘗試在本機上執行，皆無問題。 123gordonfang$ heroku ps:scale web=1Scaling dynos... !! couldn't find that process type (web). 解決方法隔一天再次檢查才發現原來朋友寫的 Procfile 多了副檔名，是 Procfile.txt ， Procfile 是 Heroku 的部署腳本，告訴他包版完後要跑哪一個檔案將 Web Server 啟動起來，重新調整完後機器人就能順利回覆訊息。 1234@handler.add(MessageEvent, message=TextMessage)def handle_message(event): message = text=event.message.text line_bot_api.reply_message(event.reply_token, TextSendMessage(message))","link":"/2022/03/12/Heroku-Couldn-t-find-that-process-type-web/"},{"title":"[Hexo] 在不同電腦上寫部落格","text":"HEXO 簡介HEXO 是一套 OPEN SOURCE 寫部落格框架，專門用來部署靜態網頁的工具，並支持 MARKDOWN 的方式撰寫，對於工程師來說非常方便，使用方式則是使用 NODE.JS 軟體套件管理系統下載，利用指令 MARKDOWN 標記語言檔案，再透過解析方式生成靜態網頁，過程十分快速、方便。 但如果你想要在不同裝置上撰寫部落格的話，就需要透過版本控制實現。 在 GITHUB 上開好分支 假設你已經有自己的 Repository，\b\b 這個 Repository 必須與自己使用者名稱相同，例如：gordonfang199649.github.io 分支上面開立分支，我自己是取名為 hexo，輸入完分支即在下方按”Create branch from master” 在 Repository 中間分頁切到 Settings 後，左邊項目中選取 Branch（分支)，我們將”hexo”設為預設分支 設置靜態網頁部署資訊這邊部署資訊要在 \b\b\b\b\b\b\b 撰寫部落格根目錄中的_config.yml 設定，我使用的是 GitHub 部署，所以 type 這邊輸入 git，repository 輸入你的 GitHub Repositroy 的 URL，分支則設置為 master，如果你是已經建立部署資訊的朋友們，可以先跳過此步驟。 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: 你的GitHub Repositroy的URL branch: master 移除主題.git 在將異動檔案上版至 hexo 分支前，要先將套主題中的.git 資料夾刪除因為 git 不容許一個以上.git 存在 12$pwd/你的hexo資料夾名稱/themes/套用主題資料夾名稱/.git 將異動檔案傳至遠端 Repository 部署文章到 master 分支 加入遠端 Repository 位置 開設分支 hexo 切換分支至 hexo 將異動檔案移動到暫存區 提交異動檔案 上版至遠端 Repository 12345678$hexo clean &amp;&amp; hexo generate$hexo deploy$git remote add origin https://github.com/usrname/usrname.github.io$git branch hexo$git checkout hexo$git add .$git commit -m &quot;commited message&quot;$git push origin hexo 在不同裝置取得最新版本（環境是已建立） 只要下”Git pull”指令就可以取得當前部落格內容最新版本每次異動檔案要上傳遠端 Repository，先從遠端 PULL 一版下來，並輸入上一節第二到第四步驟的指令 12345678$git branch hexo$git checkout hexo$git pull$hexo clean &amp;&amp; hexo generate$hexo deploy$git add .$git commit -m &quot;commited message&quot;$git push origin hexo 在不同裝置取得最新版本（環境是未建立） \b\b\b\b\b\b 若在尚未建立環境的裝置下，要先 Clone 自己的 Repository，再另行安裝 Hexo 1$git clone https://github.com/usrname/usrname.github.io.git 為什麼要另外開立分支的原因?最後部署至 GitHub 上，我們是透過”hexo deploy”指令部署到 GitHub 上的 master，另一個 hexo 分支則是儲存不同裝置上上版紀錄 \b、及資料，在替大家複習一下，若寫好文章要發佈上去，得先部署到”GitHub 的 master 分支”上，這樣才可以看得到靜態網頁，再來是將異動的檔案上到 hexo 分支，在不同裝置下都能複製一版下來再進行部落格的撰寫。 1234567$hexo clean &amp;&amp; hexo generate$hexo deploy$git branch hexo$git checkout hexo$git add .$git commit -m &quot;commited message&quot;$git push origin hexo 循序圖","link":"/2020/06/08/%5BHexo%5D%20%E5%9C%A8%E4%B8%8D%E5%90%8C%E9%9B%BB%E8%85%A6%E4%B8%8A%E5%AF%AB%E9%83%A8%E8%90%BD%E6%A0%BC/"},{"title":"[LeetCode]180. Consecutive Numbers","text":"問題描述 Write a SQL query to find all numbers that appear at least three times consecutively. Id Num 1 1 2 1 3 1 4 2 5 1 6 2 7 2 For example, given the above Logs table, 1 is the only number that appears consecutively for at least three times. ConsecutiveNums 1 翻譯 請寫出一段 SQL 查詢能找出所有連續出現三次以上的數字 解題思維 利用 LEAD(), LAG() Oracle 分析函數可分別得出該數字的上下數字，再判斷上下數字、與該數字都是否相等，即為答案。 解題報告 Level: MediumRuntime: 678 ms, faster than 98.93% of Oracle online submissions for Consecutive Numbers.Memory Usage: 0B, less than 100.00% of Oracle online submissions for Consecutive Numbers. 程式完整解題123456789/* Write your PL/SQL query statement below */SELECT NUM AS ConsecutiveNums FROM(SELECT NUM ,LEAD(NUM) OVER (ORDER BY ID) AS NEXT_NUM ,LAG(NUM) OVER (ORDER BY ID) AS LAST_NUM FROM Logs) WHERE NEXT_NUM = LAST_NUM AND NEXT_NUM = NUM GROUP BY NUM; SQL Schema123456789Create table If Not Exists Logs (Id int, Num int)Truncate table Logsinsert into Logs (Id, Num) values ('1', '1')insert into Logs (Id, Num) values ('2', '1')insert into Logs (Id, Num) values ('3', '1')insert into Logs (Id, Num) values ('4', '2')insert into Logs (Id, Num) values ('5', '1')insert into Logs (Id, Num) values ('6', '2')insert into Logs (Id, Num) values ('7', '2')","link":"/2020/07/01/%5BLeetCode%5D%20180.%20Consecutive%20Numbers/"},{"title":"[LeetCode]184. Department Highest Salary","text":"問題描述The Employee table holds all employees. Every employee has an Id, a salary, and there is also a column for the department Id. Id Name Salary DepartmentId 1 Joe 70000 1 2 Jim 90000 1 3 Henry 80000 2 4 Sam 60000 2 5 Max 90000 1 The Department table holds all departments of the company. Id Name 1 IT 2 Sales Write a SQL query to find employees who have the highest salary in each of the departments. For the above tables, your SQL query should return the following rows (order of rows does not matter). Department Employee Salary IT Max 90000 IT Jim 90000 Sales Henry 80000 Explanation: Max and Jim both have the highest salary in the IT department and Henry has the highest salary in the Sales department. 翻譯Employee 這張資料表擁有所有員工資訊，每一筆資料包含員工編號、名稱、薪水、以及部門代碼Department 這張資料表擁有公司部門資訊請撰寫一段 SQL 查詢能找出各個部門薪資最高的員工，並參考以下查詢結果格式作為解答標準（次序非必要條件）。 解題思維 部門代號可以利用 JOIN 方式將 Employee 與 Department 兩張作關聯，如此以來就可以取得部門名稱 要取得部門中最高薪資，使用 Group By 部門方式，則可以取到該部門最高薪資 最後 \b\b\b 將 1.查詢結果 JOIN2.，以薪水、部門代號作為關聯條件，就可以得出答案 解題報告 Level: MediumRuntime: 983 ms, faster than 89.78% of Oracle online submissions for Department Highest Salary.Memory Usage: 0B, less than 100.00% of Oracle online submissions for Department Highest Salary. 程式完整解題1234567891011121314/* Write your PL/SQL query statement below */SELECT DP.NAME AS DEPARTMENT -- 部門名稱 ,EM.NAME AS EMPLOYEE -- 員工名稱 ,EM.SALARY AS SALARY -- 員工薪水 FROM EMPLOYEE EM INNER JOIN DEPARTMENT DP ON EM.DEPARTMENTID = DP.ID INNER JOIN (SELECT DEPARTMENTID ,MAX(SALARY) AS SALARY FROM EMPLOYEE GROUP BY DEPARTMENTID) MAX_SALARY ON EM.SALARY = MAX_SALARY.SALARY AND EM.DEPARTMENTID = MAX_SALARY.DEPARTMENTID; SQL Schema1234567891011Create table If Not Exists Employee (Id int, Name varchar(255), Salary int, DepartmentId int)Create table If Not Exists Department (Id int, Name varchar(255))Truncate table Employeeinsert into Employee (Id, Name, Salary, DepartmentId) values ('1', 'Joe', '70000', '1')insert into Employee (Id, Name, Salary, DepartmentId) values ('2', 'Jim', '90000', '1')insert into Employee (Id, Name, Salary, DepartmentId) values ('3', 'Henry', '80000', '2')insert into Employee (Id, Name, Salary, DepartmentId) values ('4', 'Sam', '60000', '2')insert into Employee (Id, Name, Salary, DepartmentId) values ('5', 'Max', '90000', '1')Truncate table Departmentinsert into Department (Id, Name) values ('1', 'IT')insert into Department (Id, Name) values ('2', 'Sales')","link":"/2020/06/12/%5BLeetCode%5D%20184-Department-Highest-Salary/"},{"title":"[LeetCode] 185. Department Top Three Salaries","text":"問題描述The Employee table holds all employees. Every employee has an Id, and there is also a column for the department Id. Id Name Salary DepartmentId 1 Joe 85000 1 2 Henry 80000 2 3 Sam 60000 2 4 Max 90000 1 5 Janet 69000 1 6 Randy 85000 1 7 Will 70000 1 The Department table holds all departments of the company. Id Name 1 IT 2 Sales Write a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows (order of rows does not matter). Department Employee Salary IT Max 90000 IT Randy 85000 IT Joe 85000 IT Will 70000 Sales Henry 80000 Sales Sam 60000 翻譯 Employee 表格紀錄員工資訊，每位員工擁有 Id, 及所屬部門代碼。 Department 表格紀錄公司所有部門資訊。 請撰寫一段 SQL 查詢，找出各部門業績排行的前三名，同名並列。 解題思維 利用 DENSE_RANK()函數以部門代號切割，業績從高至低排名最後撈取前三名(含)，就可得出答案 解題報告 Level: HardRuntime: 1173 ms, faster than 80.22% of Oracle online submissions for Department Top Three Salaries.Memory Usage: 0B, less than 100.00% of Oracle online submissions for Department Top Three Salaries. 程式完整解題123456789101112/* Write your PL/SQL query statement below */SELECT DEPARTMENT ,EMPLOYEE ,SALARY FROM(SELECT DP.NAME AS DEPARTMENT ,EM.NAME AS EMPLOYEE ,EM.SALARY AS SALARY ,DENSE_RANK() OVER(PARTITION BY EM.DEPARTMENTID ORDER BY EM.SALARY DESC) AS RANK FROM EMPLOYEE EM JOIN DEPARTMENT DP ON EM.DEPARTMENTID = DP.ID) WHERE RANK &lt;= 3; SQL Schema12345678910111213Create table If Not Exists Employee (Id int, Name varchar(255), Salary int, DepartmentId int)Create table If Not Exists Department (Id int, Name varchar(255))Truncate table Employeeinsert into Employee (Id, Name, Salary, DepartmentId) values ('1', 'Joe', '85000', '1')insert into Employee (Id, Name, Salary, DepartmentId) values ('2', 'Henry', '80000', '2')insert into Employee (Id, Name, Salary, DepartmentId) values ('3', 'Sam', '60000', '2')insert into Employee (Id, Name, Salary, DepartmentId) values ('4', 'Max', '90000', '1')insert into Employee (Id, Name, Salary, DepartmentId) values ('5', 'Janet', '69000', '1')insert into Employee (Id, Name, Salary, DepartmentId) values ('6', 'Randy', '85000', '1')insert into Employee (Id, Name, Salary, DepartmentId) values ('7', 'Will', '70000', '1')Truncate table Departmentinsert into Department (Id, Name) values ('1', 'IT')insert into Department (Id, Name) values ('2', 'Sales')","link":"/2020/07/03/%5BLeetCode%5D%20185.%20Department%20Top%20Three%20Salaries/"},{"title":"[LeetCode] 226. Invert Binary Tree","text":"問題描述Invert a binary tree. Example 翻譯翻轉這顆二元樹 解題思維 使用 level Order 方式拜訪這顆二元樹，用佇列將每一層 \b 節點儲存起來 同時檢查拜訪該節點是否有左右子樹，若有加入佇列裡面 交換左右節點 重複第二、三步驟直至佇列為空 解題報告 Level: EasyTime Complexity: O(n)Runtime: 0 ms, faster than 100.00% of Java online submissions for Invert Binary Tree.Memory Usage: 37.4 MB, less than 5.10% of Java online submissions for Invert Binary Tree. 程式完整解題12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */import java.util.Queue;import java.util.LinkedList;class Solution { public TreeNode invertTree(TreeNode root) { if(root==null) return root; Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;(); q.add(root); while(!q.isEmpty()){ TreeNode node = q.poll(); if(node.left!=null) q.add(node.left); if(node.right!=null) q.add(node.right); TreeNode temp_node = node.left; node.left = node.right ; node.right = temp_node; } return root; }}","link":"/2020/06/02/%5BLeetCode%5D%20226.%20Invert%20Binary%20Tree/"},{"title":"[LeetCode] 232. Implement Queue using Stacks","text":"問題描述Implement the following operations of a queue using stacks.1234push(x) -- Push element x to the back of queue.pop() -- Removes the element from in front of queue.peek() -- Get the front element.empty() -- Return whether the queue is empty. Example:1234567MyQueue queue = new MyQueue();queue.push(1);queue.push(2);queue.peek(); // returns 1queue.pop(); // returns 1queue.empty(); // returns false Notes:You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid.Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue). 解題思維首先我們要先釐清柱列(Queue)與 Stack(堆)的特性，前者為先進先出，後者為後進先出，題目是要我們使用堆來實現柱列的功能，我們需要用兩個堆來完成，一個存放資料，另一個暫存資料，解題主要思維是利用堆後進先出的特性，將儲存在第一個堆的資料，依序 pop 出來，同時 push 到暫存的堆裡，將要放入的資料放入第一堆，最後將暫存的堆裡依序吐出到第一堆，剛好最先進去的資料排在第一個。 Enqueue1234567891011121314151617181920/** * 實作Enqueue功能 * @param x 資料 * @remark */public void push(int x) { //依序先將存在第一個Stack吐到第二個裡 while(!stack1.empty()){ stack2.push(stack1.pop()); } //將我們儲存的元素存到第一個Stack裡 stack1.push(x); //依序將存在暫存Stack的元素依序吐回第一個Stack //維持先進去的元素排在最前面 while(!stack2.empty()){ stack1.push(stack2.pop()); } } Dequeue123456789/** * 實作Dequeue功能 * @return 返回Stack第一個元素 * @remark */public int pop() { //直接pop第一個Stack第一個元素 return stack1.pop();} 程式完整解題1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/**Runtime: 0 ms, faster than 100.00% of Java online submissions for Implement Queue using Stacks.Memory Usage: 40.9 MB, less than 6.25% of Java online submissions for Implement Queue using Stacks.*/import java.util.Stack;class MyQueue { private Stack&lt;Integer&gt; stack1; private Stack&lt;Integer&gt; stack2; /** Initialize your data structure here. */ public MyQueue() { stack1 = new Stack&lt;&gt;(); stack2 = new Stack&lt;&gt;(); } /** Push element x to the back of queue. */ public void push(int x) { while(!stack1.empty()){ stack2.push(stack1.pop()); } stack1.push(x); while(!stack2.empty()){ stack1.push(stack2.pop()); } } /** Removes the element from in front of queue and returns that element. */ public int pop() { return stack1.pop(); } /** Get the front element. */ public int peek() { return stack1.peek(); } /** Returns whether the queue is empty. */ public boolean empty() { return stack1.empty(); }}/** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */","link":"/2020/01/19/%5BLeetCode%5D%20232.%20Implement%20Queue%20using%20Stacks/"},{"title":"[LeetCode] 262. Trips and Users","text":"問題描述The Trips table holds all taxi trips. Each trip has a unique Id, while Client_Id and Driver_Id are both foreign keys to the Users_Id at the Users table. Status is an ENUM type of (‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’). Id Client_Id Driver_Id City_Id Status Request_at 1 1 10 1 completed 2013-10-01 2 2 11 1 cancelled_by_driver 2013-10-01 3 3 12 6 completed 2013-10-01 4 4 13 6 cancelled_by_client 2013-10-01 5 1 10 1 completed 2013-10-02 6 2 11 6 completed 2013-10-02 7 3 12 6 completed 2013-10-02 8 2 12 12 completed 2013-10-03 9 3 10 12 completed 2013-10-03 10 4 13 12 cancelled_by_driver 2013-10-03 The Users table holds all users. Each user has an unique Users_Id, and Role is an ENUM type of (‘client’, ‘driver’, ‘partner’). Users_Id Banned Role 1 No client 2 Yes client 3 No client 4 No client 10 No driver 11 No driver 12 No driver 13 No driver Write a SQL query to find the cancellation rate of requests made by unbanned users (both client and driver must be unbanned) between Oct 1, 2013 and Oct 3, 2013. The cancellation rate is computed by dividing the number of canceled (by client or driver) requests made by unbanned users by the total number of requests made by unbanned users. For the above tables, your SQL query should return the following rows with the cancellation rate being rounded to two decimal places. Day Cancellation Rate 2013-10-01 0.33 2013-10-02 0.00 2013-10-03 0.50 翻譯 Trips 表格紀錄所有計程車的乘車紀錄，每一筆資料 Id 為唯一值, 其中 Client_Id, Driver_Id 為外部鍵，參照 Users 表格的 Users_Id，Status 為列舉型態，表示三種狀態，分別為”完成乘車”、”司機取消載客”、”乘客取消乘車”。 Users 表格紀錄所有使用者，每一筆紀錄 Users_Id 為唯一值，其中 Role 欄位為列舉型態，分別為”司機”、”乘客”、”夥伴”。 請撰寫一段 SQL 查詢，找出 2013 年 10 月 1 日至 2013 年 10 月 3 日三日的當日乘車取消率，計算公式如下。 當日由”司機取消載客”、”乘客取消乘車”乘車紀錄次數 / 當日乘車紀錄總次數，且司機與乘客不得為禁用狀態。 解題思維 TRIPS 以 JOIN 方式關聯 Users 兩次，條件分別為乘客、司機非禁用狀態，時間篩選在 2013 年 10 月 1 日至 2013 年 10 月 3 日三日再 COUNT, SUM 函數分別對第一步驟的結果計算出乘車紀錄總次數、取消乘車紀錄次數最後使用 GROUP BY 方式，就可以得出三日當日的乘車取消率 解題報告 Level: HardRuntime: 796 ms, faster than 82.29% of Oracle online submissions for Trips and Users.Memory Usage: 0B, less than 100.00% of Oracle online submissions for Trips and Users. 程式完整解題12345678910111213141516171819202122232425/* Write your PL/SQL query statement below */WITH TAXI AS(SELECT TRIPS.STATUS AS STATUS ,TRIPS.REQUEST_AT AS REQUESTED_DATE FROM TRIPS JOIN Users CLIENTS ON (CLIENTS.Users_Id = TRIPS.CLIENT_ID) AND CLIENTS.BANNED = 'No' JOIN Users DRIVERS ON (DRIVERS.Users_Id = TRIPS.CLIENT_ID) AND DRIVERS.BANNED = 'No' WHERE TO_DATE(TRIPS.REQUEST_AT, 'YYYY-MM-DD') BETWEEN TO_DATE('2013-10-01', 'YYYY-MM-DD') AND TO_DATE('2013-10-03', 'YYYY-MM-DD'))SELECT TOTAL_REQ.REQ_DATE AS &quot;Day&quot; ,ROUND(CANCELLEDL_REQ.TIMES *1.0/ TOTAL_REQ.TIMES, 2) AS &quot;Cancellation Rate&quot; FROM (SELECT REQUESTED_DATE AS REQ_DATE ,COUNT(*) AS TIMES FROM TAXI GROUP BY REQUESTED_DATE) TOTAL_REQ JOIN(SELECT REQUESTED_DATE AS REQ_DATE ,SUM(CASE WHEN (STATUS = 'cancelled_by_client' OR STATUS = 'cancelled_by_driver') THEN 1 ELSE 0 END) AS TIMES FROM TAXI GROUP BY REQUESTED_DATE) CANCELLEDL_REQ ON TOTAL_REQ.REQ_DATE = CANCELLEDL_REQ.REQ_DATE ORDER BY TOTAL_REQ.REQ_DATE SQL Schema12345678910111213141516171819202122Create table If Not Exists Trips (Id int, Client_Id int, Driver_Id int, City_Id int, Status ENUM('completed', 'cancelled_by_driver', 'cancelled_by_client'), Request_at varchar(50))Create table If Not Exists Users (Users_Id int, Banned varchar(50), Role ENUM('client', 'driver', 'partner'))Truncate table Tripsinsert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values ('1', '1', '10', '1', 'completed', '2013-10-01')insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values ('2', '2', '11', '1', 'cancelled_by_driver', '2013-10-01')insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values ('3', '3', '12', '6', 'completed', '2013-10-01')insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values ('4', '4', '13', '6', 'cancelled_by_client', '2013-10-01')insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values ('5', '1', '10', '1', 'completed', '2013-10-02')insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values ('6', '2', '11', '6', 'completed', '2013-10-02')insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values ('7', '3', '12', '6', 'completed', '2013-10-02')insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values ('8', '2', '12', '12', 'completed', '2013-10-03')insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values ('9', '3', '10', '12', 'completed', '2013-10-03')insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values ('10', '4', '13', '12', 'cancelled_by_driver', '2013-10-03')Truncate table Usersinsert into Users (Users_Id, Banned, Role) values ('1', 'No', 'client')insert into Users (Users_Id, Banned, Role) values ('2', 'Yes', 'client')insert into Users (Users_Id, Banned, Role) values ('3', 'No', 'client')insert into Users (Users_Id, Banned, Role) values ('4', 'No', 'client')insert into Users (Users_Id, Banned, Role) values ('10', 'No', 'driver')insert into Users (Users_Id, Banned, Role) values ('11', 'No', 'driver')insert into Users (Users_Id, Banned, Role) values ('12', 'No', 'driver')insert into Users (Users_Id, Banned, Role) values ('13', 'No', 'driver')","link":"/2020/07/03/%5BLeetCode%5D%20262.%20Trips%20and%20Users/"},{"title":"[LeetCode] 509. Fibonacci Number","text":"問題描述The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is, F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), for N &gt; 1.Given N, calculate F(N). Example: 翻譯 經典不敗題型 費式數列，通常使用 F(n)來表示數列，每一個數都是由前兩個數所構成的，頭兩個數值分別為 0,1 解題思維 遞迴版本：每次呼叫 fib(N-1)+fib(N-2)，若 N 為 0 則回傳 0,1 則回傳 1，最終回傳答案 迭代版本：先開好 N 個空間的陣列，頭兩個元素分別設為 1,1，透過迭代方式，最後回傳最後一個元素 解題報告 Level: EasyTime Complexity: O(n)Runtime: 0 ms, faster than 100.00% of Java online submissions for Fibonacci Number.Memory Usage: 36.3 MB, less than 5.51% of Java online submissions for Fibonacci Number. 程式完整解題1234567891011121314151617181920212223class Solution { //遞迴版本 public int fib(int N) { if(N&lt;=1) return N; return fib(N-1)+fib(N-2); } //迭代版本 public int fib(int n) { if(n&lt;2){ return n; }else { int[] ans = new int[n]; ans[0] = 1; ans[1] = 1; for(int i=2;i&lt;n;i++) { ans[i]=ans[i-1]+ans[i-2]; } return ans[n-1]; } }}","link":"/2020/06/05/%5BLeetCode%5D%20509.%20Fibonacci%20Number/"},{"title":"[LeetCode] 66. Plus One","text":"問題描述Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Example 1:Input: [1,2,3]Output: [1,2,4]Explanation: The array represents the integer 123.Example 2: Input: [4,3,2,1]Output: [4,3,2,2]Explanation: The array represents the integer 4321. 翻譯給定一個非空存正整數位數的陣列，你要替這串數值加上一最高有效數位存放在陣列初始位置，數值每個數字各依序別存在陣列裡頭你能假定這串整數不以零開頭，除了本身為零 解題思維 先替陣列最後一個數值加上一 以迭代方式判斷是否大於 9，以此判斷是否要進位 最後判斷進位的變數是否不等於零，若不為零，將進位數填入陣列第一個位置，將計算後陣列依序填入新的陣列 解題報告 Level: EasyTime Complexity: O(n)Runtime: 0 ms, faster than 100.00% of Java online submissions for Plus One.Memory Usage: 37.9 MB, less than 5.64% of Java online submissions for Plus One. 程式完整解題12345678910111213141516171819202122232425262728class Solution { /** 數值陣列加一 * @param 數值陣列 * @return 加一後的數值陣列 */ public int[] plusOne(int[] digits) { digits[digits.length - 1 ] += 1; int carry = 0; for(int i = digits.length - 1 ; i &gt;= 0 ; i--){ digits[i] += carry; if(digits[i] &gt; 9){ digits[i] %= 10; carry = 1; } else{ carry = 0; } } if(carry == 1){ int[] answer = new int[digits.length + 1 ]; answer[0] = carry; System.arraycopy(answer, 1, digits, 0, digits.length); return answer; } return digits; }}","link":"/2020/05/31/%5BLeetCode%5D%2066.%20Plus%20One/"},{"title":"[LeetCode] 844. Backspace String Compare","text":"題目連結844. Backspace String Compare 問題描述Given two strings s and t, return true if they are equal when both are typed into empty text editors. ‘#’ means a backspace character. Note that after backspacing an empty text, the text will continue empty. Example 1:Input: s = “ab#c”, t = “ad#c”Output: trueExplanation: Both s and t become “ac”.Example 2: Input: s = “ab##”, t = “c#d#”Output: trueExplanation: Both s and t become “”.Example 3: Input: s = “a##c”, t = “#a#c”Output: trueExplanation: Both s and t become “c”.Example 4: Input: s = “a#c”, t = “b”Output: falseExplanation: s becomes “c” while t becomes “b”. 翻譯 給定兩字串分別是s、 跟t，被輸入到空的文字編輯器的這兩段字串如果是一樣，則回傳true，#表示一個退格鍵。 請注意在空字串輸入退格鍵，這段文字仍為空白。 解題思維從字串頭讀到字串尾的解法 準備一個Stack，以迭代方式讀取兩個字串中各個字元，將其儲存到Stack 當讀取到字元是退格鍵#，\b將\b\b目前儲存在Stack第一個字元pop ‘#’不儲到Stack 最後將仍儲存在Stack的字元輸出成字串，即可以比對兩串字串是否一樣 請參考Java解法 從字串尾讀到字串頭的解法 從字串尾開始讀取各個字元 當讀取到字元是退格鍵#，\b累加變數 變數用來決定讀取下一個字元是否要跳過 變數大於0，跳過該字元 最後比對去除刪除部分字元字串是否一樣 請參考C++解法 解題報告 Level: EasyTime Complexity: O(n)Runtime: 0 ms, faster than 100.00% of C++ online submissions for Backspace String Compare.Memory Usage: 6.3 MB, less than 57.92% of C++ online submissions for Backspace String Compare. 程式完整解題Java 解法123456789101112131415161718192021222324class Solution { public boolean backspaceCompare(String s, String t) { return removeBackSpaces(s).removeBackSpaces(t); } private String removeBackSpaces(String str){ Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); StringBuilder builder = new StringBuilder(); for(char c : str.toCharArray()){ if(c == '#') { if(!stack.isEmpty()) { stack.pop(); } } else { stack.push(c); } } while(!stack.isEmpty()){ builder.append(stack.pop()); } return builder.toString(); }} C++ 解法123456789101112131415161718192021222324#include &lt;string&gt;class Solution {public: bool backspaceCompare(string s, string t) { return removeBackSpaces(s).compare(removeBackSpaces(t)) == 0; }private: string removeBackSpaces(string str) { string newString; int skip = 0; for(int i = str.length() - 1; i &gt;= 0; i--) { if(str[i] == '#') { skip++; } else { if(skip &gt; 0) { skip--; } else { newString.push_back(str[i]); } } } return newString; }};","link":"/2021/06/27/%5BLeetCode%5D%20844.%20Backspace%20String%20Compare/"},{"title":"[LeetCode] 88. Merge Sorted Array","text":"問題描述Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note:The number of elements initialized in nums1 and nums2 are m and n respectively.You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. ExampleInput:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] 翻譯給定兩個排序過整數陣列，請將兩組陣列合併成一個排序過後的陣列nums1、nums2 陣列大小分別為 m、n，你可以假定 nums1 有足夠的額外空間(空間可能是 n + m，或者更大)存放從 num2 陣列的元素。 解題思維 由於已知 num1 有足夠空間存放來自 num2 的元素，所以我們可以將 num2 元素從 num1 末端插入 重新排序 解題報告 Level: EasyTime Complexity: O(nlog(n))Runtime: 0 ms, faster than 100.00% of Java online submissions for Merge Sorted Array.Memory Usage: 39.7 MB, less than 5.94% of Java online submissions for Merge Sorted Array. 程式完整解題12345678910111213141516import java.util.Arrays;class Solution { /** *@param nums1 陣列一 *@param m 陣列一大小 *@param nums2 陣列二 *@param n 陣列二大小 *@return **/ public void merge(int[] nums1, int m, int[] nums2, int n) { for(int i = m ; i &lt; n + m ; i++) nums1[i] = nums2[i-m]; Arrays.sort(nums1); }}","link":"/2020/06/01/%5BLeetCode%5D%2088-Merge-Sorted-Array/"},{"title":"[LeetCode]178. Rank Scores","text":"問題描述Write a SQL query to rank scores. If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no “holes” between ranks. Id Score 1 3.50 2 3.65 3 4.00 4 3.85 5 4.00 6 3.65 For example, given the above Scores table, your query should generate the following report (order by highest score): score Rank 4.00 1 4.00 1 3.85 2 3.65 3 3.65 3 3.50 4 Important Note: For MySQL solutions, to escape reserved words used as column names, you can use an apostrophe before and after the keyword. For example Rank. 翻譯請撰寫一段 SQL 查詢排名以下分數，若兩個分數趨近一樣，將並列為同一名次，下一個名次取次排名，換言之，並列後的分數後不會空出排名。您必須產出如以下的依據分數從高至低的查詢結果。注意：如果是以 MySql 作答，你可以在 Rank 前後加入撇號(`)來跳脫保留字當作是欄位名稱。 解題思維用法： [ROW_NUM()|RANK()|DENSE_RANK()] OVER([PARTITION BY 欄位名稱] ORDER BY 欄位名稱 [DESC|ASC])解題是利用 Oracle 分析函數進行排名，詳細可參考[Oracle SQL] rank(), dense_rank(), row_number()分析函數用法 解題報告 Level: MediumRuntime: 544 ms, faster than 93.42% of Oracle online submissions for Rank Scores.Memory Usage: 0B, less than 100.00% of Oracle online submissions for Rank Scores. 程式完整解題1234/* Write your PL/SQL query statement below */SELECT SCORE ,DENSE_RANK() OVER (ORDER BY SCORE DESC) AS RANK FROM SCORES; SQL Schema12345678Create table If Not Exists Scores (Id int, Score DECIMAL(3,2))Truncate table Scoresinsert into Scores (Id, Score) values ('1', '3.5')insert into Scores (Id, Score) values ('2', '3.65')insert into Scores (Id, Score) values ('3', '4.0')insert into Scores (Id, Score) values ('4', '3.85')insert into Scores (Id, Score) values ('5', '4.0')insert into Scores (Id, Score) values ('6', '3.65')","link":"/2020/06/13/%5BLeetCode%5D178.%20Rank%20Scores/"},{"title":"[Oracle SQL] rank()分析函數用法","text":"分析函數簡介RANK(), DENSE_RANK(), ROW_RANK()都是 Oracle SQL 的分析函數，可根據分群、排序依據分配序列給每一筆資料，可以套用在成績、業績排名、或是群組內排名等等，以下使用員工薪水作為範例，範例會有兩張表格分別為 EMPLOYEE, DEPARTMENT，實作部分會告訴各位三種函數有何差別。 TABLE SCHEMA1234567891011121314151617181920212223242526CREATE TABLE DEPARTMENT ( DEPT_ID NUMBER NOT NULL, DEPT_NAME VARCHAR2(10 CHAR), CONSTRAINT DEPARTMENT_PK PRIMARY KEY(DEPT_ID));CREATE TABLE EMPLOYEE ( EMPLOYEE_ID NUMBER NOT NULL, DEPT_ID NUMBER NOT NULL, NAME VARCHAR2(20 CHAR), SALARY NUMBER, CONSTRAINT EMPLOYEE_PK PRIMARY KEY (EMPLOYEE_ID), CONSTRAINT DEPARTMENT_FK FOREIGN KEY (DEPT_ID) REFERENCES DEPARTMENT(DEPT_ID));INSERT INTO DEPARTMENT VALUES( 1, 'IT');INSERT INTO DEPARTMENT VALUES( 2, 'ACCT');INSERT INTO DEPARTMENT VALUES( 3, 'MAINT' );INSERT INTO EMPLOYEE VALUES( 1, 1, 'Terry' , 50000);INSERT INTO EMPLOYEE VALUES( 2, 1, 'Emily' , 50000);INSERT INTO EMPLOYEE VALUES( 3, 2, 'Joyce' , 38600);INSERT INTO EMPLOYEE VALUES( 4, 2, 'Bob' , 32800);INSERT INTO EMPLOYEE VALUES( 5, 2, 'Phoebe', 32800);INSERT INTO EMPLOYEE VALUES( 6, 3, 'Olive' , 28000);COMMIT; 語法使用ROW_NUM()、RANK()、DENSE_RANK()是分析函數用來分派序列給每一筆資料，ORDER BY 欄位名稱 [DESC|ASC]指的是要依據什麼欄位進行遞減[增]排序，此為必填子句，[PARTITION BY 欄位名稱]指的是要依照什麼欄位進行分群，例如：班級、單位內排序，此為選填子句，若沒有這段子句，則會針對所有的資料分派序列。 12[ROW_NUM()|RANK()|DENSE_RANK()]OVER([PARTITION BY 欄位名稱] ORDER BY 欄位名稱 [DESC|ASC]) RANK()使用方法 範例是依據員工薪水高低做排名，若排序資料值趨近一樣，RANK()函數會將排序名次並列，並列後的排名則佔用名次，再往後排序。 12345SELECT EM.EMPLOYEE_ID AS EMPLOYEE_ID ,EM.NAME AS EMPLOYEE_NAME ,EM.SALARY AS EMPLOYEE_SALARY ,RANK() OVER (ORDER BY EM.SALARY DESC) AS SALARY_RANK FROM EMPLOYEE EM; 查詢結果 EMPLOYEE_ID EMPLOYEE_NAME EMPLOYEE_SALARY SALARY_RANK 1 Terry 50000 1 2 Emily 50000 1 3 Joyce 38600 3 4 Bob 32800 4 5 Phoebe 32800 4 6 Olive 28000 6 DENSE_RANK()使用方法 DENSE_RANK()函數與 RANK()函數使用方式很相似，兩者差別在於並列後的名次並不會佔用。 12345SELECT EM.EMPLOYEE_ID AS EMPLOYEE_ID ,EM.NAME AS EMPLOYEE_NAME ,EM.SALARY AS EMPLOYEE_SALARY ,DENSE_RANK() OVER (ORDER BY EM.SALARY DESC) AS SALARY_RANK FROM EMPLOYEE EM; 查詢結果 EMPLOYEE_ID EMPLOYEE_NAME EMPLOYEE_SALARY SALARY_RANK 1 Terry 50000 1 2 Emily 50000 1 3 Joyce 38600 2 4 Bob 32800 3 5 Phoebe 32800 3 6 Olive 28000 4 ROW_NUMBER()使用方法 ROW_NUMBER()函數是並不考慮排序並列的情況，序列依序分派下來。 12345SELECT EM.EMPLOYEE_ID AS EMPLOYEE_ID ,EM.NAME AS EMPLOYEE_NAME ,EM.SALARY AS EMPLOYEE_SALARY ,ROW_NUMBER() OVER (ORDER BY EM.SALARY DESC) AS SALARY_RANK FROM EMPLOYEE EM; 查詢結果 EMPLOYEE_ID EMPLOYEE_NAME EMPLOYEE_SALARY SALARY_RANK 1 Terry 50000 1 2 Emily 50000 2 3 Joyce 38600 3 4 Bob 32800 4 5 Phoebe 32800 5 6 Olive 28000 6 分群排名 以下範例依據部門分群排名 12345678SELECT EM.EMPLOYEE_ID AS EMPLOYEE_ID ,EM.NAME AS EMPLOYEE_NAME ,DP.DEPT_NAME AS DEPT_NAME ,EM.SALARY AS EMPLOYEE_SALARY ,DENSE_RANK() OVER (PARTITION BY EM.DEPT_ID ORDER BY EM.SALARY DESC) AS SALARY_RANK FROM EMPLOYEE EM INNER JOIN DEPARTMENT DP ON EM.DEPT_ID = DP.DEPT_ID; 查詢結果 EMPLOYEE_ID EMPLOYEE_NAME DEPT_NAME EMPLOYEE_SALARY SALARY_RANK 1 Terry IT 50000 1 2 Emily IT 50000 1 3 Joyce ACCT 38600 1 4 Bob ACCT 32800 2 5 Phoebe ACCT 32800 2 6 Olive MAINT 28000 1 完整程式碼1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374CREATE OR REPLACE PROCEDURE PROC_DROP_TAB_IF_EXISTS( v_table_name IN VARCHAR2 --TABLE NAME) IS --INITIALIZE ROW NUMBER VARIABLE v_count NUMBER;BEGIN v_count := 0; SELECT COUNT(1) INTO v_count FROM USER_TABLES WHERE TABLE_NAME = v_table_name; IF v_count &gt; 0 THEN EXECUTE IMMEDIATE 'DROP TABLE '|| v_table_name ||' CASCADE CONSTRAINTS PURGE'; END IF;END;EXECUTE PROC_DROP_TAB_IF_EXISTS('DEPARTMENT');EXECUTE PROC_DROP_TAB_IF_EXISTS('EMPLOYEE');CREATE TABLE DEPARTMENT ( DEPT_ID NUMBER NOT NULL, DEPT_NAME VARCHAR2(10 CHAR), CONSTRAINT DEPARTMENT_PK PRIMARY KEY(DEPT_ID));CREATE TABLE EMPLOYEE ( EMPLOYEE_ID NUMBER NOT NULL, DEPT_ID NUMBER NOT NULL, NAME VARCHAR2(20 CHAR), SALARY NUMBER, CONSTRAINT EMPLOYEE_PK PRIMARY KEY (EMPLOYEE_ID), CONSTRAINT DEPARTMENT_FK FOREIGN KEY (DEPT_ID) REFERENCES DEPARTMENT(DEPT_ID));INSERT INTO DEPARTMENT VALUES( 1, 'IT');INSERT INTO DEPARTMENT VALUES( 2, 'ACCT');INSERT INTO DEPARTMENT VALUES( 3, 'MAINT' );INSERT INTO EMPLOYEE VALUES( 1, 1, 'Terry' , 50000);INSERT INTO EMPLOYEE VALUES( 2, 1, 'Emily' , 50000);INSERT INTO EMPLOYEE VALUES( 3, 2, 'Joyce' , 38600);INSERT INTO EMPLOYEE VALUES( 4, 2, 'Bob' , 32800);INSERT INTO EMPLOYEE VALUES( 5, 2, 'Phoebe', 32800);INSERT INTO EMPLOYEE VALUES( 6, 3, 'Olive' , 28000);COMMIT;SELECT EM.EMPLOYEE_ID AS EMPLOYEE_ID ,EM.NAME AS EMPLOYEE_NAME ,EM.SALARY AS EMPLOYEE_SALARY ,RANK() OVER (ORDER BY EM.SALARY DESC) AS SALARY_RANK FROM EMPLOYEE EM;SELECT EM.EMPLOYEE_ID AS EMPLOYEE_ID ,EM.NAME AS EMPLOYEE_NAME ,EM.SALARY AS EMPLOYEE_SALARY ,ROW_NUMBER() OVER (ORDER BY EM.SALARY DESC) AS SALARY_RANK FROM EMPLOYEE EM;SELECT EM.EMPLOYEE_ID AS EMPLOYEE_ID ,EM.NAME AS EMPLOYEE_NAME ,EM.SALARY AS EMPLOYEE_SALARY ,DENSE_RANK() OVER (ORDER BY EM.SALARY DESC) AS SALARY_RANK FROM EMPLOYEE EM;SELECT EM.EMPLOYEE_ID AS EMPLOYEE_ID ,EM.NAME AS EMPLOYEE_NAME ,DP.DEPT_NAME AS DEPT_NAME ,EM.SALARY AS EMPLOYEE_SALARY ,DENSE_RANK() OVER (PARTITION BY EM.DEPT_ID ORDER BY EM.SALARY DESC) AS SALARY_RANK FROM EMPLOYEE EM INNER JOIN DEPARTMENT DP ON EM.DEPT_ID = DP.DEPT_ID; 參考Oracle ROW_NUMBERhttps://www.oracletutorial.com/oracle-analytic-functions/oracle-row_number/ Oracle PL/SQL: Rank 排名次查詢https://tomkuo139.blogspot.com/2009/04/plsql-rank.html Oracle 中 rank() over, dense_rank(), row_number() 的区别https://blog.csdn.net/baidu_37107022/article/details/78033513","link":"/2020/06/14/%5BOracle%20SQL%5D%20rank()%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B8%E7%94%A8%E6%B3%95/"},{"title":"[Spring] Set exposeProxy property on Advised to true","text":"問題描述我在工作上有一個需求需要使用多執行緒完整多個工項，每一個工作都是獨立事務交易，所以我使用Java 8 CompletableFuture提供的方法實作Runnable，再利用Spring AOP代理機制處理事務交易，但當我發送Http Request到我的AP Server時，卻收到下述報錯訊息，從中可以得知發生此錯誤的原因有兩種可能，一、沒有打開代理Java @EnableAspectJAutoProxy(exposeProxy = true, proxyTargetClass = true)，另一個可能是不是在同一條執行緒使用代理機制，後來我才意識到我使用了不同的執行緒代理是無法生效的。 1java.util.concurrent.ExecutionException: java.lang.IllegalStateException: Cannot find current proxy: Set exposeProxy property on Advised to 'true' to make it available, and ensure that AopContext.currentProxy() is invoked in the same thread as the AOP invocation context. 我就好奇為什麼AOP代理機制為不能跨執行緒，於是我去翻AopContext的source code，我才發現原來它是從ThreadLocal取得目前的代理類別，ThreadLocal本身特性就專屬於一個執行緒使用，其他的執行緒不能存取、修改。 12345678910111213141516public final class AopContext { private static final ThreadLocal&lt;Object&gt; currentProxy = new NamedThreadLocal&lt;&gt;(&quot;Current AOP proxy&quot;); private AopContext() { } public static Object currentProxy() throws IllegalStateException { Object proxy = currentProxy.get(); if (proxy == null) { throw new IllegalStateException( &quot;Cannot find current proxy: Set 'exposeProxy' property on Advised to 'true' to make it available, and &quot; + &quot;ensure that AopContext.currentProxy() is invoked in the same thread as the AOP invocation context.&quot;); } return proxy; }} 範例以下範例模擬我當時工作時發生的錯誤，在raiseEmployeeSalary()先到MongoDB撈所有員工的資料後，以多執行緒方式替員工加薪數額，由raiseSalary()完成，CompletableFuture.allOf意思是等所有員工加完薪水後，繼續往下作。如同上一節我所描述的，在透過代理機制去呼叫raiseSalary()就會報錯。 12345678910111213141516171819202122@Servicepublic class EmployeeService { @Autowired private EmployeeDao employeeDao; @Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRED) public void raiseEmployeeSalary(RaiseSalaryBo raiseSalaryBo) throws ExecutionException, InterruptedException { List&lt;Employee&gt; employees = employeeDao.listAllEmployees(); List&lt;CompletableFuture&lt;?&gt;&gt; tasks = new ArrayList&lt;&gt;(); for (Employee employee : employees) { tasks.add(CompletableFuture.runAsync(()-&gt;((EmployeeService)AopContext.currentProxy()).raiseSalary(employee, raiseSalaryBo.getBonus()))); } CompletableFuture.allOf(tasks.toArray(new CompletableFuture&lt;?&gt;[0])).get(); } @Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRES_NEW) public void raiseSalary(Employee employee, BigDecimal bonus) { employeeDao.raiseSalary(employee, bonus); }} 解決方法解決方法十分簡單，如若真的需要切割出子事務交易，那就不能使多執行緒來處理，依據上述範例必須把CompletableFuture移除，程式才能正常執行。 12345678910111213141516171819@Servicepublic class EmployeeService { @Autowired private EmployeeDao employeeDao; @Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRED) public void raiseEmployeeSalary(RaiseSalaryBo raiseSalaryBo) { List&lt;Employee&gt; employees = employeeDao.listAllEmployees(); for (Employee employee : employees) { ((EmployeeService) AopContext.currentProxy()).raiseSalary(employee, raiseSalaryBo.getBonus()); } } @Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRES_NEW) public void raiseSalary(Employee employee, BigDecimal bonus) { employeeDao.raiseSalary(employee, bonus); }} 資料庫更新後的結果","link":"/2022/03/07/%5BSpring%5D%20Set%20exposeProxy%20property%20on%20Advised%20to%20true/"},{"title":"[影像處理] 全彩圖片轉256色","text":"圖片資料壓縮 - 全彩轉換成索引色圖片索引色概念 - Indexed color 在計算機領域當中，索引色是一種資料壓縮的技巧，主要是用來快速呈現圖片、或是加速資料傳輸，也稱之「向量量化壓縮」。如果一張圖片是上述方式編碼，顏色資訊就不會直接存在該張圖片裡，而是另外一個檔案中稱「調色盤」，以陣列的方式儲存，陣列中的每一個元素都代表著一個顏色。 換言之，該張圖片並不包含原圖的所有顏色，而是參照另一個檔案所提供的顏色，編寫而成。 調色盤的大小 - Palette size ALPHA RED GREEN BLUE BIT POSITION 31-24 23-16 15-8 7-0 一張數位全彩影像(含透明值)由 32 個位元所組成，Alpha、紅、綠、藍各占 4 個 bit，可以表示的顏色為 2 的 24 次方，相當為 16,777,216‬ 個顏色，我們可以得知控制位元大小可以控制可以表現出來的色彩。 調色盤為儲存索引顏色的地方，最常見有 4 色、 16 色、或 256 色，電腦數字表示都是 01 表示法，會根據位元的多寡來呈現，所以色彩種類都是 2 的次方。256 色就是由一個位元組(8 個位元)所組成的，4 個位元則可以表示 16 種顏色，以此類推。 PNG 圖檔、或是視訊覆蓋技術有使用到透明值，調色盤會額外保留一個位置來儲存透明值。 轉換公式 - Formula 在本作品裡頭是使用 256 種索引色彩，我使用歐幾里德距離公式對一張全彩的圖片進行色彩置換，我們國中所學的數學公式正好可以運用在此，利用巢狀走訪所有的像素值，將該像素值的 RGB 值與 256 色的索引色套此公式，會得到一個數值，求出數值差異最小的寫入一張空白的圖片上。 公式：dist((r1, r2), (g1, g2), (b1, b2)) = √((r1 - r2)² + (g1 - g2)² + (b1 - b2)²) 進一步說明，這套公式是在歐氏空間內求出距離，一顆像素值有紅、綠、藍，如果我們將紅、綠、藍視為座標，這顆像素則存在在三維空間，另外我們是用這顆像素值跟索引色比較，兩顆像素形成一向量。 主要程式1234567891011121314151617181920for(int i=0; i&lt;height; i++){ for(int j=0; j&lt;width; j++){ //變數是原圖像素值 Color c = new Color(image.getRGB(j, i)); //distance陣列存放歐幾里德公式算出的距離 double distance[]=new double[256]; int minindex=0; //抓取最小距離的索引色之索引 double min = Math.sqrt(Math.pow((c.getRed()-r[0]),2)+Math.pow((c.getGreen()-g[0]),2)+Math.pow((c.getBlue()-b[0]),2)); //兩兩比較算出最小距離 for(int d=1;d&lt;256; d++){ distance[d]= Math.sqrt(Math.pow((c.getRed()-r[d]),2)+Math.pow((c.getGreen()-g[d]),2)+Math.pow((c.getBlue()-b[d]),2)); if(min&gt;distance[d]){ min = distance[d]; minindex = d; } } //上色，填上索引色 buff.setRGB(j, i,palette[minindex]);} 作品結果原圖 處理過的圖片","link":"/2020/06/11/%5B%E5%BD%B1%E5%83%8F%E8%99%95%E7%90%86%5D%20%E5%85%A8%E5%BD%A9%E5%9C%96%E7%89%87%E8%BD%89256%E8%89%B2/"},{"title":"[Hexo] 如何在 Hexo 開發環境的文章中加入 LikeCoin button","text":"前言LikeCoin 是一種加密虛擬貨幣，基於以太坊區塊鏈鎖延伸出來的代幣。不知道大家是不是在瀏覽網站是不是常常看到像 Medium 拍手按鈕， LikeCoin 基金會會依據別人給創作者的按讚數配發其發行虛擬幣幣給創作者，當 LikeCoin 數達到 2,000 時就可以兌換成法定貨幣。我想在自己的 Hexo 網頁放置 LikeCoin 主要原因為我很喜歡它的配色、 Logo 的設計，另一個原因是欣賞它的創作生態圈治理理念。 LikeCoin 加入到 Hexo 本篇文章是以 Hexo icarus 主題設定為主，且預設您已經註冊 LikeCoin 。 官方網站是以 Hexo next 主題為範例，而我的主題目前是使用 icarus ， next 的模板引擎是用 ejs ，而 icarus 則是用 React 的 jsx ，所以設定上就有些許不同。 LikeCoin button Gitbook 官方範例1234567&lt;div&gt; &lt;script type=&quot;text/javascript&quot;&gt; document.write( &quot;&lt;iframe scrolling='no' frameborder='0' sandbox='allow-scripts allow-same-origin allow-popups allow-popups-to-escape-sandbox allow-storage-access-by-user-activation' style='height: 212px; width: 100%;' src='https://button.like.co/in/embed/[LikerID]/button?referrer=&quot; + encodeURIComponent(location.href.split(&quot;?&quot;)[0].split(&quot;#&quot;)[0]) + &quot;'&gt;&lt;/iframe&gt;&quot;); &lt;/script&gt;&lt;div&gt; icarus 主題預設可以設定 donate 的連結，可以透過 _config.icarus.yml 去做設定，它根據 yml 屬性找到對應連結的圖片，再渲染到前端頁面的卡片上。 _config.icarus.yml12345678910111213donates: # &quot;Buy me a coffee&quot; donate button configurations - type: buymeacoffee # URL to the &quot;Buy me a coffee&quot; page url: '你的buymeacoffee URL' # Paypal donate button configurations - type: paypal # Paypal business ID or email address business: 'paypal ID' # Currency code currency_code: USD #收款幣別 donates.jsx 原始碼12345678910111213141516171819202122232425262728293031323334const logger = require('hexo-log')();const { Component } = require('inferno');const view = require('hexo-component-inferno/lib/core/view');module.exports = class extends Component { render() { const { config, helper } = this.props; const { __ } = helper; const { donates = [] } = config; if (!Array.isArray(donates) || !donates.length) { return null; } return &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-content&quot;&gt; &lt;h3 class=&quot;menu-label has-text-centered&quot;&gt;{__('donate.title')}&lt;/h3&gt; &lt;div class=&quot;buttons is-centered&quot;&gt; {donates.map(service =&gt; { const type = service.type; if (typeof type === 'string') { try { let Donate = view.require('donate/' + type); Donate = Donate.Cacheable ? Donate.Cacheable : Donate; return &lt;Donate helper={helper} donate={service} /&gt;; } catch (e) { logger.w(`Icarus cannot load donate button &quot;${type}&quot;`); } } return null; })} &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;; }}; 魔改 icarus 原始碼由於我是使用 npm 下載主題，所以主題外框、文章、頁面元件會放在你資料夾的 node_modules/hexo-theme-icarus/layout/common/ 底下，我是在 common 資料夾底下新建一個 jsx 檔元件，此元件去繼承 React.Component ，繼承下來的 sub class 去覆寫 render() 方法，我們方法回傳官方網站提供 iframe 標籤的內容，iframe src 屬性的 [LikerID] 換成自己的 LikerID ，最後我們將建立好的類別輸出出去，我的檔案取名叫 likecoin.jsx。 likecoin.jsx1234567const { Component } = require('inferno');module.exports = class extends Component { render() { return &lt;iframe scrolling='no' frameborder='0' sandbox='allow-scripts allow-same-origin allow-popups allow-popups-to-escape-sandbox allow-storage-access-by-user-activation' style='height: 212px; width: 100%;' src='https://button.like.co/in/embed/[LikerID]/button?referrer=&quot; + encodeURIComponent(location.href.split(&quot;?&quot;)[0].split(&quot;#&quot;)[0]) + &quot;'&gt;&lt;/iframe&gt;; }} 原先包住在 &lt;div class=&quot;buttons is-centered&quot;&gt;...&lt;/div&gt; 原始碼以迭代方式尋找在使用者在 _config.icarus.yml 設定的 donate type 有沒有在對應的type，再把type帶進去 Donate渲染出來，那我們要改的就是這一段，接著我們將 likecoin.jsx 引入到 donates.jsx ，使用標籤將元件包住，並取代剛剛我們提到的地方，由於我們不需要再透過 config 檔尋找 donate type ，所以我有把 _config.icarus.yml donate 那一塊刪掉，原始碼原本判斷 donates 是否為陣列及陣列長度也一併移除。 donates.jsx12345678910111213141516171819const logger = require('hexo-log')();const { Component } = require('inferno');const LikeCoin = require('./likecoin');const view = require('hexo-component-inferno/lib/core/view');module.exports = class extends Component { render() { const { helper } = this.props; const { __ } = helper; return &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-content&quot;&gt; &lt;h3 class=&quot;menu-label has-text-centered&quot;&gt;{__('donate.title')}&lt;/h3&gt; &lt;div class=&quot;is-centered&quot;&gt; &lt;LikeCoin&gt;&lt;/LikeCoin&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;; }}; 參考資源 如何在 Hexo 開發環境的文章中加入 LikeCoin button React.Component","link":"/2022/03/12/%E5%A6%82%E4%BD%95%E5%9C%A8-Hexo-%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83%E7%9A%84%E6%96%87%E7%AB%A0%E4%B8%AD%E5%8A%A0%E5%85%A5-LikeCoin-button/"}],"tags":[{"name":"Azure DevOps","slug":"Azure-DevOps","link":"/tags/Azure-DevOps/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Number","slug":"Number","link":"/tags/Number/"},{"name":"Heroku","slug":"Heroku","link":"/tags/Heroku/"},{"name":"Flask","slug":"Flask","link":"/tags/Flask/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"PL&#x2F;SQL","slug":"PL-SQL","link":"/tags/PL-SQL/"},{"name":"Tree","slug":"Tree","link":"/tags/Tree/"},{"name":"Queue","slug":"Queue","link":"/tags/Queue/"},{"name":"Array","slug":"Array","link":"/tags/Array/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"LinkedList","slug":"LinkedList","link":"/tags/LinkedList/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/tags/Spring-Boot/"},{"name":"Image Processing","slug":"Image-Processing","link":"/tags/Image-Processing/"},{"name":"LikeCoin","slug":"LikeCoin","link":"/tags/LikeCoin/"},{"name":"BlockChain","slug":"BlockChain","link":"/tags/BlockChain/"}],"categories":[{"name":"Azure DevOps","slug":"Azure-DevOps","link":"/categories/Azure-DevOps/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Heroku","slug":"Heroku","link":"/categories/Heroku/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"Oracle SQL","slug":"Oracle-SQL","link":"/categories/Oracle-SQL/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/categories/Spring-Boot/"},{"name":"Image Processing","slug":"Image-Processing","link":"/categories/Image-Processing/"}]}