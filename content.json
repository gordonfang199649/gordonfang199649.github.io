{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"[LeetCode]180. Consecutive Numbers","text":"問題描述 Write a SQL query to find all numbers that appear at least three times consecutively. Id Num 1 1 2 1 3 1 4 2 5 1 6 2 7 2 For example, given the above Logs table, 1 is the only number that appears consecutively for at least three times. ConsecutiveNums 1 翻譯 請寫出一段 SQL 查詢能找出所有連續出現三次以上的數字 解題思維 利用 LEAD(), LAG() Oracle 分析函數可分別得出該數字的上下數字，再判斷上下數字、與該數字都是否相等，即為答案。 解題報告 Level: MediumRuntime: 678 ms, faster than 98.93% of Oracle online submissions for Consecutive Numbers.Memory Usage: 0B, less than 100.00% of Oracle online submissions for Consecutive Numbers. 程式完整解題123456789/* Write your PL/SQL query statement below */SELECT NUM AS ConsecutiveNums FROM(SELECT NUM ,LEAD(NUM) OVER (ORDER BY ID) AS NEXT_NUM ,LAG(NUM) OVER (ORDER BY ID) AS LAST_NUM FROM Logs) WHERE NEXT_NUM = LAST_NUM AND NEXT_NUM = NUM GROUP BY NUM; SQL Schema123456789Create table If Not Exists Logs (Id int, Num int)Truncate table Logsinsert into Logs (Id, Num) values ('1', '1')insert into Logs (Id, Num) values ('2', '1')insert into Logs (Id, Num) values ('3', '1')insert into Logs (Id, Num) values ('4', '2')insert into Logs (Id, Num) values ('5', '1')insert into Logs (Id, Num) values ('6', '2')insert into Logs (Id, Num) values ('7', '2')","link":"/2020/07/01/%5BLeetCode%5D%20180.%20Consecutive%20Numbers/"},{"title":"[LeetCode]184. Department Highest Salary","text":"問題描述The Employee table holds all employees. Every employee has an Id, a salary, and there is also a column for the department Id. Id Name Salary DepartmentId 1 Joe 70000 1 2 Jim 90000 1 3 Henry 80000 2 4 Sam 60000 2 5 Max 90000 1 The Department table holds all departments of the company. Id Name 1 IT 2 Sales Write a SQL query to find employees who have the highest salary in each of the departments. For the above tables, your SQL query should return the following rows (order of rows does not matter). Department Employee Salary IT Max 90000 IT Jim 90000 Sales Henry 80000 Explanation: Max and Jim both have the highest salary in the IT department and Henry has the highest salary in the Sales department. 翻譯Employee 這張資料表擁有所有員工資訊，每一筆資料包含員工編號、名稱、薪水、以及部門代碼Department 這張資料表擁有公司部門資訊請撰寫一段 SQL 查詢能找出各個部門薪資最高的員工，並參考以下查詢結果格式作為解答標準（次序非必要條件）。 解題思維 部門代號可以利用 JOIN 方式將 Employee 與 Department 兩張作關聯，如此以來就可以取得部門名稱 要取得部門中最高薪資，使用 Group By 部門方式，則可以取到該部門最高薪資 最後 \b\b\b 將 1.查詢結果 JOIN2.，以薪水、部門代號作為關聯條件，就可以得出答案 解題報告 Level: MediumRuntime: 983 ms, faster than 89.78% of Oracle online submissions for Department Highest Salary.Memory Usage: 0B, less than 100.00% of Oracle online submissions for Department Highest Salary. 程式完整解題1234567891011121314/* Write your PL/SQL query statement below */SELECT DP.NAME AS DEPARTMENT -- 部門名稱 ,EM.NAME AS EMPLOYEE -- 員工名稱 ,EM.SALARY AS SALARY -- 員工薪水 FROM EMPLOYEE EM INNER JOIN DEPARTMENT DP ON EM.DEPARTMENTID = DP.ID INNER JOIN (SELECT DEPARTMENTID ,MAX(SALARY) AS SALARY FROM EMPLOYEE GROUP BY DEPARTMENTID) MAX_SALARY ON EM.SALARY = MAX_SALARY.SALARY AND EM.DEPARTMENTID = MAX_SALARY.DEPARTMENTID; SQL Schema1234567891011Create table If Not Exists Employee (Id int, Name varchar(255), Salary int, DepartmentId int)Create table If Not Exists Department (Id int, Name varchar(255))Truncate table Employeeinsert into Employee (Id, Name, Salary, DepartmentId) values ('1', 'Joe', '70000', '1')insert into Employee (Id, Name, Salary, DepartmentId) values ('2', 'Jim', '90000', '1')insert into Employee (Id, Name, Salary, DepartmentId) values ('3', 'Henry', '80000', '2')insert into Employee (Id, Name, Salary, DepartmentId) values ('4', 'Sam', '60000', '2')insert into Employee (Id, Name, Salary, DepartmentId) values ('5', 'Max', '90000', '1')Truncate table Departmentinsert into Department (Id, Name) values ('1', 'IT')insert into Department (Id, Name) values ('2', 'Sales')","link":"/2020/06/12/%5BLeetCode%5D%20184-Department-Highest-Salary/"},{"title":"[LeetCode] 185. Department Top Three Salaries","text":"問題描述The Employee table holds all employees. Every employee has an Id, and there is also a column for the department Id. Id Name Salary DepartmentId 1 Joe 85000 1 2 Henry 80000 2 3 Sam 60000 2 4 Max 90000 1 5 Janet 69000 1 6 Randy 85000 1 7 Will 70000 1 The Department table holds all departments of the company. Id Name 1 IT 2 Sales Write a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows (order of rows does not matter). Department Employee Salary IT Max 90000 IT Randy 85000 IT Joe 85000 IT Will 70000 Sales Henry 80000 Sales Sam 60000 翻譯 Employee 表格紀錄員工資訊，每位員工擁有 Id, 及所屬部門代碼。 Department 表格紀錄公司所有部門資訊。 請撰寫一段 SQL 查詢，找出各部門業績排行的前三名，同名並列。 解題思維 利用 DENSE_RANK()函數以部門代號切割，業績從高至低排名最後撈取前三名(含)，就可得出答案 解題報告 Level: HardRuntime: 1173 ms, faster than 80.22% of Oracle online submissions for Department Top Three Salaries.Memory Usage: 0B, less than 100.00% of Oracle online submissions for Department Top Three Salaries. 程式完整解題123456789101112/* Write your PL/SQL query statement below */SELECT DEPARTMENT ,EMPLOYEE ,SALARY FROM(SELECT DP.NAME AS DEPARTMENT ,EM.NAME AS EMPLOYEE ,EM.SALARY AS SALARY ,DENSE_RANK() OVER(PARTITION BY EM.DEPARTMENTID ORDER BY EM.SALARY DESC) AS RANK FROM EMPLOYEE EM JOIN DEPARTMENT DP ON EM.DEPARTMENTID = DP.ID) WHERE RANK &lt;= 3; SQL Schema12345678910111213Create table If Not Exists Employee (Id int, Name varchar(255), Salary int, DepartmentId int)Create table If Not Exists Department (Id int, Name varchar(255))Truncate table Employeeinsert into Employee (Id, Name, Salary, DepartmentId) values ('1', 'Joe', '85000', '1')insert into Employee (Id, Name, Salary, DepartmentId) values ('2', 'Henry', '80000', '2')insert into Employee (Id, Name, Salary, DepartmentId) values ('3', 'Sam', '60000', '2')insert into Employee (Id, Name, Salary, DepartmentId) values ('4', 'Max', '90000', '1')insert into Employee (Id, Name, Salary, DepartmentId) values ('5', 'Janet', '69000', '1')insert into Employee (Id, Name, Salary, DepartmentId) values ('6', 'Randy', '85000', '1')insert into Employee (Id, Name, Salary, DepartmentId) values ('7', 'Will', '70000', '1')Truncate table Departmentinsert into Department (Id, Name) values ('1', 'IT')insert into Department (Id, Name) values ('2', 'Sales')","link":"/2020/07/03/%5BLeetCode%5D%20185.%20Department%20Top%20Three%20Salaries/"},{"title":"[LeetCode] 226. Invert Binary Tree","text":"問題描述Invert a binary tree. Example 翻譯翻轉這顆二元樹 解題思維 使用 level Order 方式拜訪這顆二元樹，用佇列將每一層 \b 節點儲存起來 同時檢查拜訪該節點是否有左右子樹，若有加入佇列裡面 交換左右節點 重複第二、三步驟直至佇列為空 解題報告 Level: EasyTime Complexity: O(n)Runtime: 0 ms, faster than 100.00% of Java online submissions for Invert Binary Tree.Memory Usage: 37.4 MB, less than 5.10% of Java online submissions for Invert Binary Tree. 程式完整解題12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */import java.util.Queue;import java.util.LinkedList;class Solution { public TreeNode invertTree(TreeNode root) { if(root==null) return root; Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;(); q.add(root); while(!q.isEmpty()){ TreeNode node = q.poll(); if(node.left!=null) q.add(node.left); if(node.right!=null) q.add(node.right); TreeNode temp_node = node.left; node.left = node.right ; node.right = temp_node; } return root; }}","link":"/2020/06/02/%5BLeetCode%5D%20226.%20Invert%20Binary%20Tree/"},{"title":"[LeetCode] 232. Implement Queue using Stacks","text":"問題描述Implement the following operations of a queue using stacks.1234push(x) -- Push element x to the back of queue.pop() -- Removes the element from in front of queue.peek() -- Get the front element.empty() -- Return whether the queue is empty. Example:1234567MyQueue queue = new MyQueue();queue.push(1);queue.push(2);queue.peek(); // returns 1queue.pop(); // returns 1queue.empty(); // returns false Notes:You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid.Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue). 解題思維首先我們要先釐清柱列(Queue)與 Stack(堆)的特性，前者為先進先出，後者為後進先出，題目是要我們使用堆來實現柱列的功能，我們需要用兩個堆來完成，一個存放資料，另一個暫存資料，解題主要思維是利用堆後進先出的特性，將儲存在第一個堆的資料，依序 pop 出來，同時 push 到暫存的堆裡，將要放入的資料放入第一堆，最後將暫存的堆裡依序吐出到第一堆，剛好最先進去的資料排在第一個。 Enqueue1234567891011121314151617181920/** * 實作Enqueue功能 * @param x 資料 * @remark */public void push(int x) { //依序先將存在第一個Stack吐到第二個裡 while(!stack1.empty()){ stack2.push(stack1.pop()); } //將我們儲存的元素存到第一個Stack裡 stack1.push(x); //依序將存在暫存Stack的元素依序吐回第一個Stack //維持先進去的元素排在最前面 while(!stack2.empty()){ stack1.push(stack2.pop()); } } Dequeue123456789/** * 實作Dequeue功能 * @return 返回Stack第一個元素 * @remark */public int pop() { //直接pop第一個Stack第一個元素 return stack1.pop();} 程式完整解題1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/**Runtime: 0 ms, faster than 100.00% of Java online submissions for Implement Queue using Stacks.Memory Usage: 40.9 MB, less than 6.25% of Java online submissions for Implement Queue using Stacks.*/import java.util.Stack;class MyQueue { private Stack&lt;Integer&gt; stack1; private Stack&lt;Integer&gt; stack2; /** Initialize your data structure here. */ public MyQueue() { stack1 = new Stack&lt;&gt;(); stack2 = new Stack&lt;&gt;(); } /** Push element x to the back of queue. */ public void push(int x) { while(!stack1.empty()){ stack2.push(stack1.pop()); } stack1.push(x); while(!stack2.empty()){ stack1.push(stack2.pop()); } } /** Removes the element from in front of queue and returns that element. */ public int pop() { return stack1.pop(); } /** Get the front element. */ public int peek() { return stack1.peek(); } /** Returns whether the queue is empty. */ public boolean empty() { return stack1.empty(); }}/** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */","link":"/2020/01/19/%5BLeetCode%5D%20232.%20Implement%20Queue%20using%20Stacks/"},{"title":"[LeetCode] 509. Fibonacci Number","text":"問題描述The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is, F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), for N &gt; 1.Given N, calculate F(N). Example: 翻譯 經典不敗題型 費式數列，通常使用 F(n)來表示數列，每一個數都是由前兩個數所構成的，頭兩個數值分別為 0,1 解題思維 遞迴版本：每次呼叫 fib(N-1)+fib(N-2)，若 N 為 0 則回傳 0,1 則回傳 1，最終回傳答案 迭代版本：先開好 N 個空間的陣列，頭兩個元素分別設為 1,1，透過迭代方式，最後回傳最後一個元素 解題報告 Level: EasyTime Complexity: O(n)Runtime: 0 ms, faster than 100.00% of Java online submissions for Fibonacci Number.Memory Usage: 36.3 MB, less than 5.51% of Java online submissions for Fibonacci Number. 程式完整解題1234567891011121314151617181920212223class Solution { //遞迴版本 public int fib(int N) { if(N&lt;=1) return N; return fib(N-1)+fib(N-2); } //迭代版本 public int fib(int n) { if(n&lt;2){ return n; }else { int[] ans = new int[n]; ans[0] = 1; ans[1] = 1; for(int i=2;i&lt;n;i++) { ans[i]=ans[i-1]+ans[i-2]; } return ans[n-1]; } }}","link":"/2020/06/05/%5BLeetCode%5D%20509.%20Fibonacci%20Number/"},{"title":"[LeetCode] 262. Trips and Users","text":"問題描述The Trips table holds all taxi trips. Each trip has a unique Id, while Client_Id and Driver_Id are both foreign keys to the Users_Id at the Users table. Status is an ENUM type of (‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’). Id Client_Id Driver_Id City_Id Status Request_at 1 1 10 1 completed 2013-10-01 2 2 11 1 cancelled_by_driver 2013-10-01 3 3 12 6 completed 2013-10-01 4 4 13 6 cancelled_by_client 2013-10-01 5 1 10 1 completed 2013-10-02 6 2 11 6 completed 2013-10-02 7 3 12 6 completed 2013-10-02 8 2 12 12 completed 2013-10-03 9 3 10 12 completed 2013-10-03 10 4 13 12 cancelled_by_driver 2013-10-03 The Users table holds all users. Each user has an unique Users_Id, and Role is an ENUM type of (‘client’, ‘driver’, ‘partner’). Users_Id Banned Role 1 No client 2 Yes client 3 No client 4 No client 10 No driver 11 No driver 12 No driver 13 No driver Write a SQL query to find the cancellation rate of requests made by unbanned users (both client and driver must be unbanned) between Oct 1, 2013 and Oct 3, 2013. The cancellation rate is computed by dividing the number of canceled (by client or driver) requests made by unbanned users by the total number of requests made by unbanned users. For the above tables, your SQL query should return the following rows with the cancellation rate being rounded to two decimal places. Day Cancellation Rate 2013-10-01 0.33 2013-10-02 0.00 2013-10-03 0.50 翻譯 Trips 表格紀錄所有計程車的乘車紀錄，每一筆資料 Id 為唯一值, 其中 Client_Id, Driver_Id 為外部鍵，參照 Users 表格的 Users_Id，Status 為列舉型態，表示三種狀態，分別為”完成乘車”、”司機取消載客”、”乘客取消乘車”。 Users 表格紀錄所有使用者，每一筆紀錄 Users_Id 為唯一值，其中 Role 欄位為列舉型態，分別為”司機”、”乘客”、”夥伴”。 請撰寫一段 SQL 查詢，找出 2013 年 10 月 1 日至 2013 年 10 月 3 日三日的當日乘車取消率，計算公式如下。 當日由”司機取消載客”、”乘客取消乘車”乘車紀錄次數 / 當日乘車紀錄總次數，且司機與乘客不得為禁用狀態。 解題思維 TRIPS 以 JOIN 方式關聯 Users 兩次，條件分別為乘客、司機非禁用狀態，時間篩選在 2013 年 10 月 1 日至 2013 年 10 月 3 日三日再 COUNT, SUM 函數分別對第一步驟的結果計算出乘車紀錄總次數、取消乘車紀錄次數最後使用 GROUP BY 方式，就可以得出三日當日的乘車取消率 解題報告 Level: HardRuntime: 796 ms, faster than 82.29% of Oracle online submissions for Trips and Users.Memory Usage: 0B, less than 100.00% of Oracle online submissions for Trips and Users. 程式完整解題12345678910111213141516171819202122232425/* Write your PL/SQL query statement below */WITH TAXI AS(SELECT TRIPS.STATUS AS STATUS ,TRIPS.REQUEST_AT AS REQUESTED_DATE FROM TRIPS JOIN Users CLIENTS ON (CLIENTS.Users_Id = TRIPS.CLIENT_ID) AND CLIENTS.BANNED = 'No' JOIN Users DRIVERS ON (DRIVERS.Users_Id = TRIPS.CLIENT_ID) AND DRIVERS.BANNED = 'No' WHERE TO_DATE(TRIPS.REQUEST_AT, 'YYYY-MM-DD') BETWEEN TO_DATE('2013-10-01', 'YYYY-MM-DD') AND TO_DATE('2013-10-03', 'YYYY-MM-DD'))SELECT TOTAL_REQ.REQ_DATE AS &quot;Day&quot; ,ROUND(CANCELLEDL_REQ.TIMES *1.0/ TOTAL_REQ.TIMES, 2) AS &quot;Cancellation Rate&quot; FROM (SELECT REQUESTED_DATE AS REQ_DATE ,COUNT(*) AS TIMES FROM TAXI GROUP BY REQUESTED_DATE) TOTAL_REQ JOIN(SELECT REQUESTED_DATE AS REQ_DATE ,SUM(CASE WHEN (STATUS = 'cancelled_by_client' OR STATUS = 'cancelled_by_driver') THEN 1 ELSE 0 END) AS TIMES FROM TAXI GROUP BY REQUESTED_DATE) CANCELLEDL_REQ ON TOTAL_REQ.REQ_DATE = CANCELLEDL_REQ.REQ_DATE ORDER BY TOTAL_REQ.REQ_DATE SQL Schema12345678910111213141516171819202122Create table If Not Exists Trips (Id int, Client_Id int, Driver_Id int, City_Id int, Status ENUM('completed', 'cancelled_by_driver', 'cancelled_by_client'), Request_at varchar(50))Create table If Not Exists Users (Users_Id int, Banned varchar(50), Role ENUM('client', 'driver', 'partner'))Truncate table Tripsinsert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values ('1', '1', '10', '1', 'completed', '2013-10-01')insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values ('2', '2', '11', '1', 'cancelled_by_driver', '2013-10-01')insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values ('3', '3', '12', '6', 'completed', '2013-10-01')insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values ('4', '4', '13', '6', 'cancelled_by_client', '2013-10-01')insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values ('5', '1', '10', '1', 'completed', '2013-10-02')insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values ('6', '2', '11', '6', 'completed', '2013-10-02')insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values ('7', '3', '12', '6', 'completed', '2013-10-02')insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values ('8', '2', '12', '12', 'completed', '2013-10-03')insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values ('9', '3', '10', '12', 'completed', '2013-10-03')insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values ('10', '4', '13', '12', 'cancelled_by_driver', '2013-10-03')Truncate table Usersinsert into Users (Users_Id, Banned, Role) values ('1', 'No', 'client')insert into Users (Users_Id, Banned, Role) values ('2', 'Yes', 'client')insert into Users (Users_Id, Banned, Role) values ('3', 'No', 'client')insert into Users (Users_Id, Banned, Role) values ('4', 'No', 'client')insert into Users (Users_Id, Banned, Role) values ('10', 'No', 'driver')insert into Users (Users_Id, Banned, Role) values ('11', 'No', 'driver')insert into Users (Users_Id, Banned, Role) values ('12', 'No', 'driver')insert into Users (Users_Id, Banned, Role) values ('13', 'No', 'driver')","link":"/2020/07/03/%5BLeetCode%5D%20262.%20Trips%20and%20Users/"},{"title":"[LeetCode] 66. Plus One","text":"問題描述Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Example 1:Input: [1,2,3]Output: [1,2,4]Explanation: The array represents the integer 123.Example 2: Input: [4,3,2,1]Output: [4,3,2,2]Explanation: The array represents the integer 4321. 翻譯給定一個非空存正整數位數的陣列，你要替這串數值加上一最高有效數位存放在陣列初始位置，數值每個數字各依序別存在陣列裡頭你能假定這串整數不以零開頭，除了本身為零 解題思維 先替陣列最後一個數值加上一 以迭代方式判斷是否大於 9，以此判斷是否要進位 最後判斷進位的變數是否不等於零，若不為零，將進位數填入陣列第一個位置，將計算後陣列依序填入新的陣列 解題報告 Level: EasyTime Complexity: O(n)Runtime: 0 ms, faster than 100.00% of Java online submissions for Plus One.Memory Usage: 37.9 MB, less than 5.64% of Java online submissions for Plus One. 程式完整解題12345678910111213141516171819202122232425262728class Solution { /** 數值陣列加一 * @param 數值陣列 * @return 加一後的數值陣列 */ public int[] plusOne(int[] digits) { digits[digits.length - 1 ] += 1; int carry = 0; for(int i = digits.length - 1 ; i &gt;= 0 ; i--){ digits[i] += carry; if(digits[i] &gt; 9){ digits[i] %= 10; carry = 1; } else{ carry = 0; } } if(carry == 1){ int[] answer = new int[digits.length + 1 ]; answer[0] = carry; System.arraycopy(answer, 1, digits, 0, digits.length); return answer; } return digits; }}","link":"/2020/05/31/%5BLeetCode%5D%2066.%20Plus%20One/"},{"title":"[LeetCode] 88. Merge Sorted Array","text":"問題描述Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note:The number of elements initialized in nums1 and nums2 are m and n respectively.You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. ExampleInput:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] 翻譯給定兩個排序過整數陣列，請將兩組陣列合併成一個排序過後的陣列nums1、nums2 陣列大小分別為 m、n，你可以假定 nums1 有足夠的額外空間(空間可能是 n + m，或者更大)存放從 num2 陣列的元素。 解題思維 由於已知 num1 有足夠空間存放來自 num2 的元素，所以我們可以將 num2 元素從 num1 末端插入 重新排序 解題報告 Level: EasyTime Complexity: O(nlog(n))Runtime: 0 ms, faster than 100.00% of Java online submissions for Merge Sorted Array.Memory Usage: 39.7 MB, less than 5.94% of Java online submissions for Merge Sorted Array. 程式完整解題12345678910111213141516import java.util.Arrays;class Solution { /** *@param nums1 陣列一 *@param m 陣列一大小 *@param nums2 陣列二 *@param n 陣列二大小 *@return **/ public void merge(int[] nums1, int m, int[] nums2, int n) { for(int i = m ; i &lt; n + m ; i++) nums1[i] = nums2[i-m]; Arrays.sort(nums1); }}","link":"/2020/06/01/%5BLeetCode%5D%2088-Merge-Sorted-Array/"},{"title":"[LeetCode]178. Rank Scores","text":"問題描述Write a SQL query to rank scores. If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no “holes” between ranks. Id Score 1 3.50 2 3.65 3 4.00 4 3.85 5 4.00 6 3.65 For example, given the above Scores table, your query should generate the following report (order by highest score): score Rank 4.00 1 4.00 1 3.85 2 3.65 3 3.65 3 3.50 4 Important Note: For MySQL solutions, to escape reserved words used as column names, you can use an apostrophe before and after the keyword. For example Rank. 翻譯請撰寫一段 SQL 查詢排名以下分數，若兩個分數趨近一樣，將並列為同一名次，下一個名次取次排名，換言之，並列後的分數後不會空出排名。您必須產出如以下的依據分數從高至低的查詢結果。注意：如果是以 MySql 作答，你可以在 Rank 前後加入撇號(`)來跳脫保留字當作是欄位名稱。 解題思維用法： [ROW_NUM()|RANK()|DENSE_RANK()] OVER([PARTITION BY 欄位名稱] ORDER BY 欄位名稱 [DESC|ASC])解題是利用 Oracle 分析函數進行排名，詳細可參考[Oracle SQL] rank(), dense_rank(), row_number()分析函數用法 解題報告 Level: MediumRuntime: 544 ms, faster than 93.42% of Oracle online submissions for Rank Scores.Memory Usage: 0B, less than 100.00% of Oracle online submissions for Rank Scores. 程式完整解題1234/* Write your PL/SQL query statement below */SELECT SCORE ,DENSE_RANK() OVER (ORDER BY SCORE DESC) AS RANK FROM SCORES; SQL Schema12345678Create table If Not Exists Scores (Id int, Score DECIMAL(3,2))Truncate table Scoresinsert into Scores (Id, Score) values ('1', '3.5')insert into Scores (Id, Score) values ('2', '3.65')insert into Scores (Id, Score) values ('3', '4.0')insert into Scores (Id, Score) values ('4', '3.85')insert into Scores (Id, Score) values ('5', '4.0')insert into Scores (Id, Score) values ('6', '3.65')","link":"/2020/06/13/%5BLeetCode%5D178.%20Rank%20Scores/"},{"title":"[Oracle SQL] rank()分析函數用法","text":"分析函數簡介RANK(), DENSE_RANK(), ROW_RANK()都是 Oracle SQL 的分析函數，可根據分群、排序依據分配序列給每一筆資料，可以套用在成績、業績排名、或是群組內排名等等，以下使用員工薪水作為範例，範例會有兩張表格分別為 EMPLOYEE, DEPARTMENT，實作部分會告訴各位三種函數有何差別。 TABLE SCHEMA1234567891011121314151617181920212223242526CREATE TABLE DEPARTMENT ( DEPT_ID NUMBER NOT NULL, DEPT_NAME VARCHAR2(10 CHAR), CONSTRAINT DEPARTMENT_PK PRIMARY KEY(DEPT_ID));CREATE TABLE EMPLOYEE ( EMPLOYEE_ID NUMBER NOT NULL, DEPT_ID NUMBER NOT NULL, NAME VARCHAR2(20 CHAR), SALARY NUMBER, CONSTRAINT EMPLOYEE_PK PRIMARY KEY (EMPLOYEE_ID), CONSTRAINT DEPARTMENT_FK FOREIGN KEY (DEPT_ID) REFERENCES DEPARTMENT(DEPT_ID));INSERT INTO DEPARTMENT VALUES( 1, 'IT');INSERT INTO DEPARTMENT VALUES( 2, 'ACCT');INSERT INTO DEPARTMENT VALUES( 3, 'MAINT' );INSERT INTO EMPLOYEE VALUES( 1, 1, 'Terry' , 50000);INSERT INTO EMPLOYEE VALUES( 2, 1, 'Emily' , 50000);INSERT INTO EMPLOYEE VALUES( 3, 2, 'Joyce' , 38600);INSERT INTO EMPLOYEE VALUES( 4, 2, 'Bob' , 32800);INSERT INTO EMPLOYEE VALUES( 5, 2, 'Phoebe', 32800);INSERT INTO EMPLOYEE VALUES( 6, 3, 'Olive' , 28000);COMMIT; 語法使用ROW_NUM()、RANK()、DENSE_RANK()是分析函數用來分派序列給每一筆資料，ORDER BY 欄位名稱 [DESC|ASC]指的是要依據什麼欄位進行遞減[增]排序，此為必填子句，[PARTITION BY 欄位名稱]指的是要依照什麼欄位進行分群，例如：班級、單位內排序，此為選填子句，若沒有這段子句，則會針對所有的資料分派序列。 12[ROW_NUM()|RANK()|DENSE_RANK()]OVER([PARTITION BY 欄位名稱] ORDER BY 欄位名稱 [DESC|ASC]) RANK()使用方法 範例是依據員工薪水高低做排名，若排序資料值趨近一樣，RANK()函數會將排序名次並列，並列後的排名則佔用名次，再往後排序。 12345SELECT EM.EMPLOYEE_ID AS EMPLOYEE_ID ,EM.NAME AS EMPLOYEE_NAME ,EM.SALARY AS EMPLOYEE_SALARY ,RANK() OVER (ORDER BY EM.SALARY DESC) AS SALARY_RANK FROM EMPLOYEE EM; 查詢結果 EMPLOYEE_ID EMPLOYEE_NAME EMPLOYEE_SALARY SALARY_RANK 1 Terry 50000 1 2 Emily 50000 1 3 Joyce 38600 3 4 Bob 32800 4 5 Phoebe 32800 4 6 Olive 28000 6 DENSE_RANK()使用方法 DENSE_RANK()函數與 RANK()函數使用方式很相似，兩者差別在於並列後的名次並不會佔用。 12345SELECT EM.EMPLOYEE_ID AS EMPLOYEE_ID ,EM.NAME AS EMPLOYEE_NAME ,EM.SALARY AS EMPLOYEE_SALARY ,DENSE_RANK() OVER (ORDER BY EM.SALARY DESC) AS SALARY_RANK FROM EMPLOYEE EM; 查詢結果 EMPLOYEE_ID EMPLOYEE_NAME EMPLOYEE_SALARY SALARY_RANK 1 Terry 50000 1 2 Emily 50000 1 3 Joyce 38600 2 4 Bob 32800 3 5 Phoebe 32800 3 6 Olive 28000 4 ROW_NUMBER()使用方法 ROW_NUMBER()函數是並不考慮排序並列的情況，序列依序分派下來。 12345SELECT EM.EMPLOYEE_ID AS EMPLOYEE_ID ,EM.NAME AS EMPLOYEE_NAME ,EM.SALARY AS EMPLOYEE_SALARY ,ROW_NUMBER() OVER (ORDER BY EM.SALARY DESC) AS SALARY_RANK FROM EMPLOYEE EM; 查詢結果 EMPLOYEE_ID EMPLOYEE_NAME EMPLOYEE_SALARY SALARY_RANK 1 Terry 50000 1 2 Emily 50000 2 3 Joyce 38600 3 4 Bob 32800 4 5 Phoebe 32800 5 6 Olive 28000 6 分群排名 以下範例依據部門分群排名 12345678SELECT EM.EMPLOYEE_ID AS EMPLOYEE_ID ,EM.NAME AS EMPLOYEE_NAME ,DP.DEPT_NAME AS DEPT_NAME ,EM.SALARY AS EMPLOYEE_SALARY ,DENSE_RANK() OVER (PARTITION BY EM.DEPT_ID ORDER BY EM.SALARY DESC) AS SALARY_RANK FROM EMPLOYEE EM INNER JOIN DEPARTMENT DP ON EM.DEPT_ID = DP.DEPT_ID; 查詢結果 EMPLOYEE_ID EMPLOYEE_NAME DEPT_NAME EMPLOYEE_SALARY SALARY_RANK 1 Terry IT 50000 1 2 Emily IT 50000 1 3 Joyce ACCT 38600 1 4 Bob ACCT 32800 2 5 Phoebe ACCT 32800 2 6 Olive MAINT 28000 1 完整程式碼1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374CREATE OR REPLACE PROCEDURE PROC_DROP_TAB_IF_EXISTS( v_table_name IN VARCHAR2 --TABLE NAME) IS --INITIALIZE ROW NUMBER VARIABLE v_count NUMBER;BEGIN v_count := 0; SELECT COUNT(1) INTO v_count FROM USER_TABLES WHERE TABLE_NAME = v_table_name; IF v_count &gt; 0 THEN EXECUTE IMMEDIATE 'DROP TABLE '|| v_table_name ||' CASCADE CONSTRAINTS PURGE'; END IF;END;EXECUTE PROC_DROP_TAB_IF_EXISTS('DEPARTMENT');EXECUTE PROC_DROP_TAB_IF_EXISTS('EMPLOYEE');CREATE TABLE DEPARTMENT ( DEPT_ID NUMBER NOT NULL, DEPT_NAME VARCHAR2(10 CHAR), CONSTRAINT DEPARTMENT_PK PRIMARY KEY(DEPT_ID));CREATE TABLE EMPLOYEE ( EMPLOYEE_ID NUMBER NOT NULL, DEPT_ID NUMBER NOT NULL, NAME VARCHAR2(20 CHAR), SALARY NUMBER, CONSTRAINT EMPLOYEE_PK PRIMARY KEY (EMPLOYEE_ID), CONSTRAINT DEPARTMENT_FK FOREIGN KEY (DEPT_ID) REFERENCES DEPARTMENT(DEPT_ID));INSERT INTO DEPARTMENT VALUES( 1, 'IT');INSERT INTO DEPARTMENT VALUES( 2, 'ACCT');INSERT INTO DEPARTMENT VALUES( 3, 'MAINT' );INSERT INTO EMPLOYEE VALUES( 1, 1, 'Terry' , 50000);INSERT INTO EMPLOYEE VALUES( 2, 1, 'Emily' , 50000);INSERT INTO EMPLOYEE VALUES( 3, 2, 'Joyce' , 38600);INSERT INTO EMPLOYEE VALUES( 4, 2, 'Bob' , 32800);INSERT INTO EMPLOYEE VALUES( 5, 2, 'Phoebe', 32800);INSERT INTO EMPLOYEE VALUES( 6, 3, 'Olive' , 28000);COMMIT;SELECT EM.EMPLOYEE_ID AS EMPLOYEE_ID ,EM.NAME AS EMPLOYEE_NAME ,EM.SALARY AS EMPLOYEE_SALARY ,RANK() OVER (ORDER BY EM.SALARY DESC) AS SALARY_RANK FROM EMPLOYEE EM;SELECT EM.EMPLOYEE_ID AS EMPLOYEE_ID ,EM.NAME AS EMPLOYEE_NAME ,EM.SALARY AS EMPLOYEE_SALARY ,ROW_NUMBER() OVER (ORDER BY EM.SALARY DESC) AS SALARY_RANK FROM EMPLOYEE EM;SELECT EM.EMPLOYEE_ID AS EMPLOYEE_ID ,EM.NAME AS EMPLOYEE_NAME ,EM.SALARY AS EMPLOYEE_SALARY ,DENSE_RANK() OVER (ORDER BY EM.SALARY DESC) AS SALARY_RANK FROM EMPLOYEE EM;SELECT EM.EMPLOYEE_ID AS EMPLOYEE_ID ,EM.NAME AS EMPLOYEE_NAME ,DP.DEPT_NAME AS DEPT_NAME ,EM.SALARY AS EMPLOYEE_SALARY ,DENSE_RANK() OVER (PARTITION BY EM.DEPT_ID ORDER BY EM.SALARY DESC) AS SALARY_RANK FROM EMPLOYEE EM INNER JOIN DEPARTMENT DP ON EM.DEPT_ID = DP.DEPT_ID; 參考Oracle ROW_NUMBERhttps://www.oracletutorial.com/oracle-analytic-functions/oracle-row_number/ Oracle PL/SQL: Rank 排名次查詢https://tomkuo139.blogspot.com/2009/04/plsql-rank.html Oracle 中 rank() over, dense_rank(), row_number() 的区别https://blog.csdn.net/baidu_37107022/article/details/78033513","link":"/2020/06/14/%5BOracle%20SQL%5D%20rank()%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B8%E7%94%A8%E6%B3%95/"},{"title":"[影像處理] 全彩圖片轉256色","text":"圖片資料壓縮 - 全彩轉換成索引色圖片索引色概念 - Indexed color 在計算機領域當中，索引色是一種資料壓縮的技巧，主要是用來快速呈現圖片、或是加速資料傳輸，也稱之「向量量化壓縮」。如果一張圖片是上述方式編碼，顏色資訊就不會直接存在該張圖片裡，而是另外一個檔案中稱「調色盤」，以陣列的方式儲存，陣列中的每一個元素都代表著一個顏色。 換言之，該張圖片並不包含原圖的所有顏色，而是參照另一個檔案所提供的顏色，編寫而成。 調色盤的大小 - Palette size ALPHA RED GREEN BLUE BIT POSITION 31-24 23-16 15-8 7-0 一張數位全彩影像(含透明值)由 32 個位元所組成，Alpha、紅、綠、藍各占 4 個 bit，可以表示的顏色為 2 的 24 次方，相當為 16,777,216‬ 個顏色，我們可以得知控制位元大小可以控制可以表現出來的色彩。 調色盤為儲存索引顏色的地方，最常見有 4 色、 16 色、或 256 色，電腦數字表示都是 01 表示法，會根據位元的多寡來呈現，所以色彩種類都是 2 的次方。256 色就是由一個位元組(8 個位元)所組成的，4 個位元則可以表示 16 種顏色，以此類推。 PNG 圖檔、或是視訊覆蓋技術有使用到透明值，調色盤會額外保留一個位置來儲存透明值。 轉換公式 - Formula 在本作品裡頭是使用 256 種索引色彩，我使用歐幾里德距離公式對一張全彩的圖片進行色彩置換，我們國中所學的數學公式正好可以運用在此，利用巢狀走訪所有的像素值，將該像素值的 RGB 值與 256 色的索引色套此公式，會得到一個數值，求出數值差異最小的寫入一張空白的圖片上。 公式：dist((r1, r2), (g1, g2), (b1, b2)) = √((r1 - r2)² + (g1 - g2)² + (b1 - b2)²) 進一步說明，這套公式是在歐氏空間內求出距離，一顆像素值有紅、綠、藍，如果我們將紅、綠、藍視為座標，這顆像素則存在在三維空間，另外我們是用這顆像素值跟索引色比較，兩顆像素形成一向量。 主要程式1234567891011121314151617181920for(int i=0; i&lt;height; i++){ for(int j=0; j&lt;width; j++){ //變數是原圖像素值 Color c = new Color(image.getRGB(j, i)); //distance陣列存放歐幾里德公式算出的距離 double distance[]=new double[256]; int minindex=0; //抓取最小距離的索引色之索引 double min = Math.sqrt(Math.pow((c.getRed()-r[0]),2)+Math.pow((c.getGreen()-g[0]),2)+Math.pow((c.getBlue()-b[0]),2)); //兩兩比較算出最小距離 for(int d=1;d&lt;256; d++){ distance[d]= Math.sqrt(Math.pow((c.getRed()-r[d]),2)+Math.pow((c.getGreen()-g[d]),2)+Math.pow((c.getBlue()-b[d]),2)); if(min&gt;distance[d]){ min = distance[d]; minindex = d; } } //上色，填上索引色 buff.setRGB(j, i,palette[minindex]);} 作品結果原圖 處理過的圖片","link":"/2020/06/11/%5B%E5%BD%B1%E5%83%8F%E8%99%95%E7%90%86%5D%20%E5%85%A8%E5%BD%A9%E5%9C%96%E7%89%87%E8%BD%89256%E8%89%B2/"},{"title":"[Hexo] 在不同電腦上寫部落格","text":"HEXO 簡介HEXO 是一套 OPEN SOURCE 寫部落格框架，專門用來部署靜態網頁的工具，並支持 MARKDOWN 的方式撰寫，對於工程師來說非常方便，使用方式則是使用 NODE.JS 軟體套件管理系統下載，利用指令 MARKDOWN 標記語言檔案，再透過解析方式生成靜態網頁，過程十分快速、方便。 但如果你想要在不同裝置上撰寫部落格的話，就需要透過版本控制實現。 在 GITHUB 上開好分支 假設你已經有自己的 Repository，\b\b 這個 Repository 必須與自己使用者名稱相同，例如：gordonfang199649.github.io 分支上面開立分支，我自己是取名為 hexo，輸入完分支即在下方按”Create branch from master” 在 Repository 中間分頁切到 Settings 後，左邊項目中選取 Branch（分支)，我們將”hexo”設為預設分支 設置靜態網頁部署資訊這邊部署資訊要在 \b\b\b\b\b\b\b 撰寫部落格根目錄中的_config.yml 設定，我使用的是 GitHub 部署，所以 type 這邊輸入 git，repository 輸入你的 GitHub Repositroy 的 URL，分支則設置為 master，如果你是已經建立部署資訊的朋友們，可以先跳過此步驟。 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: 你的GitHub Repositroy的URL branch: master 移除主題.git 在將異動檔案上版至 hexo 分支前，要先將套主題中的.git 資料夾刪除因為 git 不容許一個以上.git 存在 12$pwd/你的hexo資料夾名稱/themes/套用主題資料夾名稱/.git 將異動檔案傳至遠端 Repository 部署文章到 master 分支 加入遠端 Repository 位置 開設分支 hexo 切換分支至 hexo 將異動檔案移動到暫存區 提交異動檔案 上版至遠端 Repository 12345678$hexo clean &amp;&amp; hexo generate$hexo deploy$git remote add origin https://github.com/usrname/usrname.github.io$git branch hexo$git checkout hexo$git add .$git commit -m &quot;commited message&quot;$git push origin hexo 在不同裝置取得最新版本（環境是已建立） 只要下”Git pull”指令就可以取得當前部落格內容最新版本每次異動檔案要上傳遠端 Repository，先從遠端 PULL 一版下來，並輸入上一節第二到第四步驟的指令 12345678$git branch hexo$git checkout hexo$git pull$hexo clean &amp;&amp; hexo generate$hexo deploy$git add .$git commit -m &quot;commited message&quot;$git push origin hexo 在不同裝置取得最新版本（環境是未建立） \b\b\b\b\b\b 若在尚未建立環境的裝置下，要先 Clone 自己的 Repository，再另行安裝 Hexo 1$git clone https://github.com/usrname/usrname.github.io.git 為什麼要另外開立分支的原因?最後部署至 GitHub 上，我們是透過”hexo deploy”指令部署到 GitHub 上的 master，另一個 hexo 分支則是儲存不同裝置上上版紀錄 \b、及資料，在替大家複習一下，若寫好文章要發佈上去，得先部署到”GitHub 的 master 分支”上，這樣才可以看得到靜態網頁，再來是將異動的檔案上到 hexo 分支，在不同裝置下都能複製一版下來再進行部落格的撰寫。 1234567$hexo clean &amp;&amp; hexo generate$hexo deploy$git branch hexo$git checkout hexo$git add .$git commit -m &quot;commited message&quot;$git push origin hexo 循序圖","link":"/2020/06/08/%5BHexo%5D%20%E5%9C%A8%E4%B8%8D%E5%90%8C%E9%9B%BB%E8%85%A6%E4%B8%8A%E5%AF%AB%E9%83%A8%E8%90%BD%E6%A0%BC/"},{"title":"[LeetCode] 844. Backspace String Compare","text":"題目連結844. Backspace String Compare 問題描述Given two strings s and t, return true if they are equal when both are typed into empty text editors. ‘#’ means a backspace character. Note that after backspacing an empty text, the text will continue empty. Example 1:Input: s = “ab#c”, t = “ad#c”Output: trueExplanation: Both s and t become “ac”.Example 2: Input: s = “ab##”, t = “c#d#”Output: trueExplanation: Both s and t become “”.Example 3: Input: s = “a##c”, t = “#a#c”Output: trueExplanation: Both s and t become “c”.Example 4: Input: s = “a#c”, t = “b”Output: falseExplanation: s becomes “c” while t becomes “b”. 翻譯 給定兩字串分別是s、 跟t，被輸入到空的文字編輯器的這兩段字串如果是一樣，則回傳true，#表示一個退格鍵。 請注意在空字串輸入退格鍵，這段文字仍為空白。 解題思維從字串頭讀到字串尾的解法 準備一個Stack，以迭代方式讀取兩個字串中各個字元，將其儲存到Stack 當讀取到字元是退格鍵#，\b將\b\b目前儲存在Stack第一個字元pop ‘#’不儲到Stack 最後將仍儲存在Stack的字元輸出成字串，即可以比對兩串字串是否一樣 請參考Java解法 從字串尾讀到字串頭的解法 從字串尾開始讀取各個字元 當讀取到字元是退格鍵#，\b累加變數 變數用來決定讀取下一個字元是否要跳過 變數大於0，跳過該字元 最後比對去除刪除部分字元字串是否一樣 請參考C++解法 解題報告 Level: EasyTime Complexity: O(n)Runtime: 0 ms, faster than 100.00% of C++ online submissions for Backspace String Compare.Memory Usage: 6.3 MB, less than 57.92% of C++ online submissions for Backspace String Compare. 程式完整解題Java 解法123456789101112131415161718192021222324class Solution { public boolean backspaceCompare(String s, String t) { return removeBackSpaces(s).removeBackSpaces(t); } private String removeBackSpaces(String str){ Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); StringBuilder builder = new StringBuilder(); for(char c : str.toCharArray()){ if(c == '#') { if(!stack.isEmpty()) { stack.pop(); } } else { stack.push(c); } } while(!stack.isEmpty()){ builder.append(stack.pop()); } return builder.toString(); }} C++ 解法123456789101112131415161718192021222324#include &lt;string&gt;class Solution {public: bool backspaceCompare(string s, string t) { return removeBackSpaces(s).compare(removeBackSpaces(t)) == 0; }private: string removeBackSpaces(string str) { string newString; int skip = 0; for(int i = str.length() - 1; i &gt;= 0; i--) { if(str[i] == '#') { skip++; } else { if(skip &gt; 0) { skip--; } else { newString.push_back(str[i]); } } } return newString; }};","link":"/2021/06/27/%5BLeetCode%5D%20844.%20Backspace%20String%20Compare/"},{"title":"研究所放榜前心得","text":"一、心境在學期間在尚未步入社會前，我和大多數的抱持升學的學生心態是一樣的，看著大家報考研究所，自己也跟著報考，比較少去思考為何而報？上了之後要從事什麼研究？大部分會報名的學生不外乎受長輩們的建議影響，為了謀一個好的前途而去報考各校系，某種程度上，部分大學生對批判性、與獨立性思考欠佳。 步入社會由於自己考資管所在18、19年雙雙落榜，家裡的經濟迫在眉睫，我不得不暫停考研的計畫，轉換跑道到求職，所幸在家鄉獲得軟體工程師的職缺，我慶幸準備考研的知識能應用在工作上，尤其在程式開發上，可以說資料結構、與Java程式語言讓我在這份工作上站穩腳跟。 入職後的我曾與幾位同事談論過適不適合再考研究所，多數同事是持反對意見，既然有份正當的工作何苦再給自己找麻煩，且畢業後還得重新找工作，研究所並不會為我帶來太大的加分，即便我有相關的工作經驗，人資仍視我為新人。 二、研究所報考動機會報考的主要兩個因素，其一，在大學就讀期間深受專題指導教授的鼓勵，她支持我繼續再往上讀，其二，也是受大學教授影響，我曾就學期間修過一門課叫「影像處理」，在那門課習得使用Matalb、Java對數位影像進行初階操作，印象最深刻莫過於「色彩量化」與「影像藏密學」，我可以說是我大學四年修過最好玩的課，且我願意再多花兩年專研電腦視覺領域的知識。 影像存在電腦裡頭其實就是二維矩陣，可想而知多多少少都會用到線性代數進行運算，對於數學很爛的我的確嚇阻了我不少，但美國前總統杜魯門曾說過：「怕熱就不要進廚房」，既然要走這個領域就不畏懼數學。 三、補習班生活我是到21年才決定報補習班，因為補習班教材完整，可以省去不少時間蒐集教材來看，但如今我看來當初決策有點錯誤。 報錯組？資管所分成兩個組別報考，一直一來我都報考科技組，一般都是準備兩科，資料結構與計算機概論，而資管組則是資料結構換成管理資訊系統，我是到很後期才認知到自己真的不適合報資管組，管理論述欠佳，尤其是推導方面，最後在考前幾個月仍報科技組。 雖然說一開始上MIS正課我認為是錯誤的決定，但不代表老師上的不好，確實老師帶給我很大的啟發，重新思考資訊系統在企業中的定位、策略，不得不說丁棋老師是我遇過MIS上得最好的老師。 報錯系所？誠如第二點的說明，我和其他考生考研目的不同在於我不是求職導向，而是學習研究導向，且我有特定的研究目標。根據我自身的觀察，資管所的老師十分喜歡做研究，但大多研究仍與商業脫離不了關係，很少教授有開設電腦視覺相關的實驗室，我是近幾天才認知到我有興趣的研究領域可能集中在資工系底下的研究所，如：台大網路及多媒體研究所、陽明交大多媒體研究所、清大資訊應用系統研究所…等，其中我只報清大資應所，且錄取率真的是不高，約不到3%。 從以上兩點來看，我應該是被資管系給綁住，因為我從高職就是唸相關的科系上來的，不曾想過可以跳出框架，而非在乎畢業證書上是否也印製資管兩字，我想這也是我自己設下的圈套，如今看來是已經解開了。 回首過去因為我是在職考生的身份，比其他考生累得許多，不但白天要應付公司系統開發建置，晚上也要應付補習班的作業、小考、複習包羅萬象計概出題範圍，基本上過去的一年假日都是在補習班、圖書館、咖啡廳、讀書會度過的，毫無娛樂可言，在生活枯燥同時，我很感謝一路走來的戰友，陪我成長，互相切磋，討論各校的考古題。 我不認為我是個聰明的人，否則也不會從17年考到現在，考到我周遭的同學碩士都畢業了，我還在繼續奮鬥，我很佩服我的堅忍不拔的意志力、及對學習的熱忱，想對自己說辛苦了，願努力最後能化作一片天。","link":"/2022/02/28/%E7%A0%94%E7%A9%B6%E6%89%80%E6%94%BE%E6%A6%9C%E5%89%8D%E5%BF%83%E5%BE%97/"},{"title":"[Spring] Set exposeProxy property on Advised to true","text":"問題描述我在工作上有一個需求需要使用多執行緒完整多個工項，每一個工作都是獨立事務交易，所以我使用Java 8 CompletableFuture提供的方法實作Runnable，再利用Spring AOP代理機制處理事務交易，但當我發送Http Request到我的AP Server時，卻收到下述報錯訊息，從中可以得知發生此錯誤的原因有兩種可能，一、沒有打開代理Java @EnableAspectJAutoProxy(exposeProxy = true, proxyTargetClass = true)，另一個可能是不是在同一條執行緒使用代理機制，後來我才意識到我使用了不同的執行緒代理是無法生效的。 1java.util.concurrent.ExecutionException: java.lang.IllegalStateException: Cannot find current proxy: Set exposeProxy property on Advised to 'true' to make it available, and ensure that AopContext.currentProxy() is invoked in the same thread as the AOP invocation context. 我就好奇為什麼AOP代理機制為不能跨執行緒，於是我去翻AopContext的source code，我才發現原來它是從ThreadLocal取得目前的代理類別，ThreadLocal本身特性就專屬於一個執行緒使用，其他的執行緒不能存取、修改。 12345678910111213141516public final class AopContext { private static final ThreadLocal&lt;Object&gt; currentProxy = new NamedThreadLocal&lt;&gt;(&quot;Current AOP proxy&quot;); private AopContext() { } public static Object currentProxy() throws IllegalStateException { Object proxy = currentProxy.get(); if (proxy == null) { throw new IllegalStateException( &quot;Cannot find current proxy: Set 'exposeProxy' property on Advised to 'true' to make it available, and &quot; + &quot;ensure that AopContext.currentProxy() is invoked in the same thread as the AOP invocation context.&quot;); } return proxy; }} 範例以下範例模擬我當時工作時發生的錯誤，在raiseEmployeeSalary()先到MongoDB撈所有員工的資料後，以多執行緒方式替員工加薪數額，由raiseSalary()完成，CompletableFuture.allOf意思是等所有員工加完薪水後，繼續往下作。如同上一節我所描述的，在透過代理機制去呼叫raiseSalary()就會報錯。 12345678910111213141516171819202122@Servicepublic class EmployeeService { @Autowired private EmployeeDao employeeDao; @Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRED) public void raiseEmployeeSalary(RaiseSalaryBo raiseSalaryBo) throws ExecutionException, InterruptedException { List&lt;Employee&gt; employees = employeeDao.listAllEmployees(); List&lt;CompletableFuture&lt;?&gt;&gt; tasks = new ArrayList&lt;&gt;(); for (Employee employee : employees) { tasks.add(CompletableFuture.runAsync(()-&gt;((EmployeeService)AopContext.currentProxy()).raiseSalary(employee, raiseSalaryBo.getBonus()))); } CompletableFuture.allOf(tasks.toArray(new CompletableFuture&lt;?&gt;[0])).get(); } @Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRES_NEW) public void raiseSalary(Employee employee, BigDecimal bonus) { employeeDao.raiseSalary(employee, bonus); }} 解決方法解決方法十分簡單，如若真的需要切割出子事務交易，那就不能使多執行緒來處理，依據上述範例必須把CompletableFuture移除，程式才能正常執行。 12345678910111213141516171819@Servicepublic class EmployeeService { @Autowired private EmployeeDao employeeDao; @Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRED) public void raiseEmployeeSalary(RaiseSalaryBo raiseSalaryBo) { List&lt;Employee&gt; employees = employeeDao.listAllEmployees(); for (Employee employee : employees) { ((EmployeeService) AopContext.currentProxy()).raiseSalary(employee, raiseSalaryBo.getBonus()); } } @Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRES_NEW) public void raiseSalary(Employee employee, BigDecimal bonus) { employeeDao.raiseSalary(employee, bonus); }} 資料庫更新後的結果","link":"/2022/03/07/%5BSpring%5D%20Set%20exposeProxy%20property%20on%20Advised%20to%20true/"},{"title":"[Java] BigDecimal 精度計算","text":"問題實務上，我們在程式中處理與金錢相關的議題不會使用浮點數，因為那會造成Truncate Error，算出來的金額會有浮點數誤差，通常我們會使用Decimal來計算，提高計算的精度。 而我曾經要計算某金額除以匯率，計算結果四捨五入小數點取到第二位，於是我就寫了以下範例，使用BigDecimal除法，分別填入除數與MathContext，MathContext的建構子的第一參數setPrecision，我以為設定的是小數點的精度，但事與願達，結果是2.4E2即240以科學記號表示。 1234BigDecimal dividend = new BigDecimal(&quot;999999.9999&quot;);BigDecimal divisor = new BigDecimal(&quot;4096.00&quot;);BigDecimal result = dividend.divide(divisor, new MathContext(2, RoundingMode.HALF_UP));System.out.println(result); Scale, Precision傻傻分不清楚由於上述計算結果並不是我想要，我在網路上找到BigDecimal對Scale, Precision的介紹，我才赫然發現一開始我就搞錯用法了，原來BigDecimal也像IEEE 754 採用類似的表示方式。 BigDecimal表示法 Java BigDecimal 是由兩個數值所構成的，分別是隨機的精度整數、跟32位元整數範圍，通常BigDecimal以***數值 X 10^(-n)***表示，其中n為小數位數。 Precision 精度定義是未經BigDecimal正規表示的數值之位數，即該數值整數加上小數的數位，例如：123.45，此精度會回傳5。 Scale 範圍定義是經BigDecimal正規表示後的小數位數，如果Scale是零、正整數，則會將該數的數個位數挪動到小數點符號的右邊，如若Scale是負整數，則該值會乘上10的幂次，例如：12345, scale = 2，則回傳123.45，12345, scale = -1，則回傳123450。 解決方法承上述例子，因為精度是設定2，舊版的寫法會造成四捨五入到十位數，十數位以下通通進位，並以科學記號表示。解決方法是改用BigDecimal另一個重載divide的方法，就可以在第二參數設定小數範圍為2，最後結果為244.14。 12345public class BigDecimal extends Number implements Comparable&lt;BigDecimal&gt; { public BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode) { return divide(divisor, scale, roundingMode.oldMode); }} 1234BigDecimal dividend = new BigDecimal(&quot;999999.9999&quot;);BigDecimal divisor = new BigDecimal(&quot;4096.00&quot;);BigDecimal result = dividend.divide(divisor, 2, RoundingMode.HALF_UP);System.out.println(result);","link":"/2022/03/08/BigDecimal-%E7%B2%BE%E5%BA%A6%E8%A8%88%E7%AE%97/"}],"tags":[{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"PL&#x2F;SQL","slug":"PL-SQL","link":"/tags/PL-SQL/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Tree","slug":"Tree","link":"/tags/Tree/"},{"name":"Queue","slug":"Queue","link":"/tags/Queue/"},{"name":"Array","slug":"Array","link":"/tags/Array/"},{"name":"Image Processing","slug":"Image-Processing","link":"/tags/Image-Processing/"},{"name":"LinkedList","slug":"LinkedList","link":"/tags/LinkedList/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"心得","slug":"心得","link":"/tags/%E5%BF%83%E5%BE%97/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/tags/Spring-Boot/"},{"name":"Number","slug":"Number","link":"/tags/Number/"}],"categories":[{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"Oracle SQL","slug":"Oracle-SQL","link":"/categories/Oracle-SQL/"},{"name":"Image Processing","slug":"Image-Processing","link":"/categories/Image-Processing/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/categories/Spring-Boot/"},{"name":"Java","slug":"Java","link":"/categories/Java/"}]}